# 2. 시스템 구조
- 운영체제는 프로그래밍이 실행되는 환경을 제공해준다. 내부적으로, 운영체제는 여러 다른 경로를 따라 구성되므로, 그들의 구조는 크게 다르다. 새로운 운영체제를 설계하는일은 대단히 큰 작업이다. 설계를 시작하기전에 시스템의 목표를 잘 정의하는 것이 중요하다.
- 운영체제를 살필 때 운영체제가 제공하는 서비스, 운영체제가 사용자 및 프로그래머에게 제공하는 인터페이스, 시스템의 구성요소와 그들의 상호 연결 등에 관점을 가질 수 있다.

# 2.1 운영체제 서비스
운영체제는 프로그램 실행환경을 제공한다. 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다. (p.64 그림을 참조하자)
- 사용자 인터페이스: 거의 모든 운영체제는 사용자 인터페이스를 제공한다. 이 인터페이스는 여러 형태로 제공될 수 있다. 그 중 하나는 CLI 로서 문자열 명령과 이를 입력할 수 있는 방법을 사용한다. 다른 형태는 명령어와 명령어를 제어하는 디렉티브가 파일 형태로 입력되고  그 파일이 실행되는 배치 인터페이스이다. GUI는 가장 보편적인 인터페이스다.
- 프로그램 수행: 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다. 프로그램은 정상적이든 혹은 비정상적이든 실행을 끝낼 수 있어야 한다.
- 입출력 연산: 수행 중인 프로그램은 입출력을 요구할 수 있다. 이러한 입출력에는 ㅍ[ㅏ일 혹은, 입출력 장치가 연관될 수 있다.특정 장치에 대해서는 특수한 기능이 요구될 수 있다. 효율과 보호를 위해 사용자들은 통상 입출력 장치를 직접 제어할 수 없다. 따라서 운영체제가 입출력 수행의 수단을 제공해야 한다.
- 파일 시스템 조작: 파일 시스템은 특히 중요한 분야이다. 명백히, 프로그램은 파일을 읽고 쓸 필요가 있다. 프로그램은 또한 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 한다. 마지막으로 몇몇 프로그램은 파일 소유권에 기반을 둔 권한 관리를 이용하여 파일이나 디렉터리의 접근을 허가하거나 거부할 수 있게한다.
- 통신: 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 여러 상황이 있다. 이러한 통신을 수행하는 두 가지 중요한 방법이 있다. 첫번째는 동이ᅵᆯ한 컴퓨터에서 수행되고 있는 프로세스들 사이에서 일어나고, 두 번째는 컴퓨터 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템 상에서 수행되는 프로세스들 사이에서 일어난다. 통신은 공유 메모리를 통해서 구현될 수도 있고, 메시지 전달 기법에 의해 구현될 수 있는데, 후자의 경우 정보의 패킷들이 운영체제에 의해 프로세스들 사이를 이동한다.
- 오류 탐지: 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다. 오류는 CPU, 메모리 하드웨어, 입출력 장치, 또는 사용자 프로그램에서 일어날 수 있다. 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 취해야 한다. 물론 운영체제가 오류에 어떻게 반응하며 수정하는 가에 다양한 변종이 존재한다. 디버깅 설비는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상시킨다.
- 자원 할당: 다수의 사용자나 다수의 작업들이 동시에 실행될 때, 그들 각각에 자원을 할당해 주어야 한다. 운영체제는 여러 가지 다른 종류의 자원을 관리한다. 어떤 것들은 특수한 할당 코드를 가질 수 있는 반면, 다른 것들은 훨씬 일반적인 요청과 방출 코드를 가질 수 있다. 예를 들면 CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야 할 작업들, 사용 가능한 레지스터의 수와 다른 요인들을 고려하도록 해야 한다. 또한 프린터, USB 저장장치 드ㅏㄹ이브 및 다른 주변 장치를 할당하는 루틴이 있을 수 있다.
- 회계: 우리는 사용자가 어떤 종류의 첨퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있기를 원한다. 이와 같은 기록 관리는 회계, 또는 단순히 사용 통계를 내기 위해 사용된다. 사용 통계는 컴퓨팅 서비스를 개선하기 위해 시스템을 재구성하고자 하는 연구자에게 귀중한 자료가 될 수 있다.
- 보호와 보안: 다중 사용자 컴퓨터 시스템 또는 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원한다. 서로 다른 여러 프로세스가 병행하게 수행될 때 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 된다. 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. 외부로부터의 시스템 보안 또한 중요하다. 이러한 보안은 각 사용자가 자원에 대한 접근 을 원할 때 통상 패스워드를 사용해서 시스템에게 자기 자신을 인증하는 것으로부터 시작된다. 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고 침입의 탐지를 우ㅣ해 모든 접속을 기록하는 것으로 범위를 넓힌다. 만약 시스템이 보호되고 보안이 유지되려면, 시스템 전체에 걸쳐 예방책이 제정되어야 한다. 하나의 사슬은 가장 약한 연결 고리만큼만 강한 법이다.


# 2.2 사용자 운영체제 인터페이스
## 2.2.1 명령해석기(Command-Interpreter)
- 어떤 운영체제는 커널에 명령 해석기를 포함하고 있다. Windows와 UNIX같은 다른 운영체제는 명령 해석기를 작업이 시작되거나, 사용자가 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다. 선택할 수 있는 여러 명령어 해석기를 제공하는 시스템에서 이 해석기는 셸(shell)이라고 블린다.
- 명령어 해석기의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 이 수준에서 제공된 많은 명령들은 파일을 조작한다. 즉 생성, 삭제, 리스트, 프린트, 복사, 수행 등을 한다. 이 명령어들은 두가지 일반적인 방식으로 구현될 수 있다.
- 한가지 방법은 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우이다. 예를 들면 한 파일을 삭제하기 위한 명령은 명령 해석기가 자신의 코드의 한 부분으로 분기하고, 그 코드 부분이 매개변수를 설정하고 적절한 시스템 호출을 한다. 이 경우 제공될 수 있는 명령의 수가 명령 해석기의 크기를 결정하는데 그 이유는 각 명령이 자신의 쿠현 코드를 요구하기 때문이다.
- 여러 운영체제중 UNIX에 의해 사용되는 다른 대안의 접근 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다 
- 여러 운영체제 중 UNIX에 의해 사용되는 다른 대안의 접근 방법은, 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다. 이러한 경우 명령 해석기는 전혀 그 명령을 알지 못한다. 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다. 따라서 파일을 삭제하는 다음의 UNIX 명령 rm 은 파일을 챃아서, 메로리에 적재하고 수행한다. rm 명령과 관련된 기능은 rm이라는 파일 내의 코드로 완전하게 정의된다. 이러한 방법으로, 프로그래머는 적합한 이름을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다. 명령 해석기 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다.

## 2.2.2 그래피컬 사용자 인터페이스(graphical User Interface)
- 운영체제와 접촉하는 두번째 방식은 사용자 친화적인 그래피컬 사용자 인터페이스 또는 GUI를 통하는 방식이다. 이 방식에서는 명령어 라인 인터페이스를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 데스크톱이라고 특징지어지는 마우스를 기반으로 하는 윈도우 메뉴시스템을 사용한다. 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의 이미지에 위치시킨다. 마우스 포인터의 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나, 파일 혹은 디렉터리를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 잡아당길 수도 있다.
- 마우스는 대부분의 모바일 시스템에서 사용하기 어려운 장치이기 때문에 스마트폰이나 휴대형 태블릿 컴퓨터는 보통 터치스크린 인터페이스를 사용한다. 사용자들은 터치스크린 위에서 누르고 화면을 손가락으로 쓸거나 하는 등의 동작을 취함으로써 컴퓨터와 상호작용한다. 

## 2.2.3 인터페이스의 선택
- 명령어 라인 또는 그래피컬 인터페이스를 사용할 것인지는 개인의 선호에 달려있다
- 사용자 인터페이스는 시스템마다 심지어 한 시스템의 사용자마다 다를 수 있다. 통상 실제 시스템 구조에서는 지외되었다. 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것이 운영체제의 직접적인 기능은 아니다. 이 책에서는, 사용자 프로그램에 적절한 서비스를 제공하는데 있어서 근본적인 문제점들에 초점을 맞춘다. 우리는 사용자 프로그램과 시스템 프로그램을 구별하지 않는다.

# 2.3 시스템 호출(System Calls)
- 시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 특정 저수준은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C++ 언어로 작성된 루틴 형태로 제공된다.
- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하게 된다. 종종 초당 수천 개의 시스템 호출을 수행하게 된다. 대부분의 사용자들은 이러한 정도의 상세를 겹코 알지 못한다. 대부분의 응용 개발자들은 API에 따라 프로그램을 설계한다. 
- API를 따라 개발하는데에는 여러가지 이점이 있다. 그중 하나는 호환성이다. API에 따라 프로그램을 설계 하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고 실행 된다는 것으 길대할 수 있다.
- 프로그래밍 언어들을 위한 실행시간 지원 시스템은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템호출 인터페이스를 제공한다. 이 시스템 호출 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 호출을 부른다. 통상 각 시스템 호출에는 번호가 할당되고 시스템 호출 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 호출 인터페이스는 의도하는 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다.
- 호출자는 시스템 호출이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다. 호출자는 단지 API를 준수하고 시스템 호출의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다. 따라서 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 실행시간 지원 라이브러리에 의해 관리된다. (p74 그림 참조)
- 시스템 호출은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다. 종종, 단순히 원하는 시스템 호출이 무엇인지보다 더 많은 정보가 요구될 경우도 입닸. 필요한 정보ㅇ 유형과 양은 특정 운영체제와 호출에 따라 다양하다. 예를 들면 입력을 받아 들이기 위해 입력원으로 사용ᅬᆯ 파일이나 장치와 함께 읽어 들인 데이터를 저장할 메모리 버퍼의 주소와 길이를 명시할 필요가 있다. 물론 장치나 파일 그리고 길이는 시스템 호출에 암묵적일 수 있다.
- 운영체제에 매개변수를 전달하기 위해서 세 가지 일반적인 방법을 사용한다. 가장 간단한 방법은 매개 변수를 레지스터 내에 전달하는 것이다. 그러나 어떤 경우는 레지스터보다 더 많은 매개변수가 있을 수 있다. 이러한 경우에 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개 변수로 전달된다. 매개변수는 프로그램에 의해 스택에 넣어질 수 있고, 운영체제에 의해 꺼내진다. 몇몇 운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다. 

# 2.4 시스템 호출의 유형
- 시스템 호출은 다섯 가지의 중요한 범주 즉, 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등으로 묶을 수 있다.
  - 프로세스 제어
    - 끝내기, 중지
    - 적재, 수행
    - 프로세스 생성, 프로세스 종료
    - 프로세스 속성 흭득, 프로세스 속성 설정
    - 시간을 기다
    - 사건을 기다림, 사건을 알림
    - 메모리 할당 및 자유
  - 파일 조작
    - 파일 생성, 파일 삭제 
    - 열기, 닫기 
    - 읽기, 쓰기, 위치 변경 
    - 파일 속성 흭득 및 설정 
  - 장치 관리 
    - 장치를 요구, 장치를 방출
    - 읽기, 쓰기, 위치 변경
    - 장치 속성 흭득, 장치 속성 설정 
    - 장치의 논리적 부착 또는 분리
  - 정보 유지 
    - 시간과 날짜의 설정과 희득
    - 시스템 데이터의 설정과 흭득 
    - 프로세스, 파일, 장치 속성의 흭득
    - 프로세스, 파일, 장치 속성의 설정
  - 통신 
    - 통신 연결의 생성, 제고 
    - 메시지의 송신, 수신 
    - 상태 정보 전달 
    - 원격 장치의 부착 및 분리 

## 2.4.1 프로세스 제어
- 실행 중인 프로그램은 수행을 정상적으로 또는 비정상적으로 멈출 수 있어야 한다. 만약 현재 실행중인 프로그램을 비정상적으로 중지하기 위해 시스템 호출이 행해지거나 또는, 프로그램에 문제가 발생해 오류 트랩을 유발할 경우, 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다. 
- 정상이거나 비정상인 상황에서, 운영체제는 명령 해석기로 제어르 절단핼야 한다. 명령 해석기는 이어 다음 명령을 읽는다. 대화식 시스템에서 명령 해석기는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다. GUI 시스템에서는 팝업 윈도우가 사용자에게 오류를 알리고 지시를 기다린다. 일괄처리 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다. 
- 한 프로그램을 실행하고 있는 프로세스나 잡이 다른 프로그램을 적재하고 실행하기를 원할 수 있다. 이 기능은 명령 해석기가 사용자 명령, 마우스의 클릭 혹은, 일괄처리 명령 등을 통하여 지시된 프로그램을 실행하는 것을 허용한다. 여기서 흥미 있는 질문은 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐 하는 것이다 .이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련있다.
- 만약 새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다. 따라서 우리는 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다. 만약 두 프로그램이 병행하게 수행된다면, 우리는 다중 프로그래밍 될 새로운 잡이나 프로세스를 생성한 것이다.
- 만약 새로운 잡이나 프로세스 혹은, 잡들이나 프로세스들의 집합을 생성한다면, 그들의 실행을 제어할 수 있어야 한다. 이러한 제어는 잡의 우선순위, 최대 허용 실행 시간등을 포함하여 잡 혹은 프로세스ㅇ의 속성들을 결정하고 재설정할 수 있는 능력을 필요로 한다.
- 새로운 잡이나 프로세스를 생성한 후에는, 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다. 우리는 일정 시간만큼 기다리기를 원할 수 있다. 그리고 보다 가능성이 큰 경우는 우리가 특정 사건이 일어날 때까지 기다리는 것이다. 그 경우 잡이나 프로쎄드을ᅳᆫ 그 사건이 일어나면 신호를 보내야 한다.
- 둘 이상의 프로세스들은 데이터를 빈번하게 공유한다. 공유되는 데이터의 일관성을 보장하기 위해서는 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 호출을 제공한다. 그러면 잠금이 해제될 때까지 어느 프로세스도 데이터에 접근할 수 없게 된다. 통상 그런 시스템은 acquire_lock()과 release_lock() 시스템 호출을 제공한다. 
- 프로세스 잡 제어는 너무 많은 측면과 다양성이 있기 때문에, 이러한 개념들을 명확히 하기 위해 단일 태스킹 시스템과 다중 태스킹 시스템의 두 예를 사용한다.
- MS-DOS 운영체제는 단일 태스킹 시스템의 예로, 컴퓨터가 시동될 때 호출되는 하나의 명령 해석기를 가진다. 단일 태스킹이기 때문에, 하나의 프로그램을 수행하기 위해 간단한 방법을 사용하며, 새로운 프로세스를 생성하지 않는다. 프로그램을 메모리에 적재하며, 이 때 가능한 한 많은 메모리를 프로그램에 제공하기 위해 자신의 대부분을 덮어 쓴다. 이어 명령 포인터를 프로그램의 첫 번째 명령으로 설정한다. 그 다음 프로그램이 수행되며, 오류가 있을 경우는 트랩이 발생되거나, 아니면 종료를 위해 시스템 호출을 수행한다. 어느 경우든, 다음에 이용하기 위해 오류 코드가 시스템 메모리에 저장된다. 이 동작에 이어, 명령 해석기의 덮어 씨이지 않은 적은 부분이 실행을 재개한다. 이것의 첫 번째 일은 명령 해석기의 나머지를 디스크로부터 다시 적재하는 것이다. 이 일이 수행되면, 명령 해석기는 앞의 오류 코드를 사용자나 다음 프로그램이 사용할 수 있게 해준다.
- FREEBSD는 다중 태스킹 시스템의 예이다. 사용자가 시스템에 로그인할 때 사용자가 선택한 쉘이 수행된다. 이 쉘은 명령을 받아서 사용자가 요청한 프로그램을 수행한다는 점에서 MS-DOS명령 해석기와 유사하다. 하지만 FreeBSD는 다중 태스킹 시스템이기 때문에 명령 해석기는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있다. 새로운 프로세스를 시작하기 위해 쉘은 fork() 시스템 호출을 실행한다. 그런 다음, 선택된 프로그램이 exec()시스템 호출을 통해 메모리에 적재되고, 이어 그 다음 프로그램이 수행된다. 명령이 내려진 방법에 따라, 쉘은 프로세스가 종료하기를 기다리거나 백그라운드에서 프로세스를 수행한다. 후자의 경우 쉘은 바로 또 다른 명령을 요청한다. 프로세스가 백그라운드에서 수행될 때, 그 프로세스는 키보드로 부터 직접 입력을 받을 수 없는데, 이는 쉘이 그 자원을 사용하고 있기 때문이다. 따라서 입출력은 파일, 또는 GUI를 통해 행해진다. 반면에 사용자는 쉘에게 다른 프로그램을 수행하도록 요청하거나, 수행중인 프로세스의 진행사항을 감시하게 하거나, 그 프로그램의 우선순위를 변경하는 등의 요청을 자유롭게 합 수 있다. 프로세스가 끝나면, 종료하기 위해 exit() 시스템 호출을 수행하며, 호출한 프로세스에게 상태 코드 0 을 돌려주거나 0이 아닌 오류코드를 돌려준다. 이러한 상태 또는 오류 코드는 쉘 또는 다른 프로그램들이 이용할 수 있게 된다.

## 2.4.2 파일관리
- 파일 시스템이 파일을 조직하기 위해 디렉터리 구조를 가진다면, 우리는 디렉터리에 대해서도 이와 같은 연산 집합이 필요할 것이다. 추가로, 파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수 있어야 하고, 필요하다면 그것을 재설정 할 수 있어야 한다. 파일 속성은 파일 이름 파일 타입,  보호 코드, 회계 정보 등을 포함한다. 이러한 기능을 위해서는 최소한 파일 속성 흭득과 파일 속성 설정의 두 시스템 호출이 필요하다. 몇몇 운영체제는 파일 이동과 복사 등의 훨씬 더 많은 시스템 호출들을 제공한다. 일부 시스템들은 코드와 다른 시스템 호출을 이용하여 동일한 작업을 수행하는 API를 제공할 수도 있고 일부 시스템은 단순히 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 한다. 만일 이 시스템 프로그램이 다른 프로그램에 의해 호출 가능하다면 프로그램의 입장에서는 이 시스템 프로그램이 API가 된다.

## 2.4.3 장치 관리
- 프로세스는 작업을 계속 수행하기 위해 추가 자원을 필요로 할 수 있다. 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에 접근 등이 될 수 있다. 만약 자원들을 사용할 수 있다면ㅇ, 이들 자원이 주어지고, 제어가 사용자 프로그램으로 복귀될 수 있다. 그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.
- 운영체제에 의해 제어되는 다양한 자원들은 장치로 간줄될 수 있다. 이 장치들의 일부는 물리장치이고 다른 장치들은 추상적 혹은, 가상적 장치로 생각할 수 있다. 다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 우선 그 장치를 요청하는 것을 요구한다. 그 장치의 사용이 끝나면 우리는 그것을 반드시 방출해야 한다. 이러한 기능은 파일의 열기 닫기 시스템 호출과 비슷하다. 다른 운영체제들은 장치에 대해 통제되지 않은 접근을 허용한다. 
- 일단 장치를 요청하고, 파일에서와 같이 그 장치를 읽고, 쓰고 , 위치를 변경할 수 도 있다. 사실 입출력 장치와 파일들 간에는 유사성이 매우 많기 때문에, UNIX를 포함한 많은 운영체제가 이들 둘을 통합된 파일-장치 구조로 결합하였다. 이 경우 같은 시스템 호출들이 파일과 장치에 대해 사용된다 때로 입출력 장치들은 특별한 파일 이름, 디렉터리 배치 또는 파일 속성으로 식별된다.  

