# 2. 시스템 구조
- 운영체제는 프로그래밍이 실행되는 환경을 제공해준다. 내부적으로, 운영체제는 여러 다른 경로를 따라 구성되므로, 그들의 구조는 크게 다르다. 새로운 운영체제를 설계하는일은 대단히 큰 작업이다. 설계를 시작하기전에 시스템의 목표를 잘 정의하는 것이 중요하다.
- 운영체제를 살필 때 운영체제가 제공하는 서비스, 운영체제가 사용자 및 프로그래머에게 제공하는 인터페이스, 시스템의 구성요소와 그들의 상호 연결 등에 관점을 가질 수 있다.

# 2.1 운영체제 서비스
운영체제는 프로그램 실행환경을 제공한다. 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다. (p.64 그림을 참조하자)
- 사용자 인터페이스: 거의 모든 운영체제는 사용자 인터페이스를 제공한다. 이 인터페이스는 여러 형태로 제공될 수 있다. 그 중 하나는 CLI 로서 문자열 명령과 이를 입력할 수 있는 방법을 사용한다. 다른 형태는 명령어와 명령어를 제어하는 디렉티브가 파일 형태로 입력되고  그 파일이 실행되는 배치 인터페이스이다. GUI는 가장 보편적인 인터페이스다.
- 프로그램 수행: 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다. 프로그램은 정상적이든 혹은 비정상적이든 실행을 끝낼 수 있어야 한다.
- 입출력 연산: 수행 중인 프로그램은 입출력을 요구할 수 있다. 이러한 입출력에는 ㅍ[ㅏ일 혹은, 입출력 장치가 연관될 수 있다.특정 장치에 대해서는 특수한 기능이 요구될 수 있다. 효율과 보호를 위해 사용자들은 통상 입출력 장치를 직접 제어할 수 없다. 따라서 운영체제가 입출력 수행의 수단을 제공해야 한다.
- 파일 시스템 조작: 파일 시스템은 특히 중요한 분야이다. 명백히, 프로그램은 파일을 읽고 쓸 필요가 있다. 프로그램은 또한 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 한다. 마지막으로 몇몇 프로그램은 파일 소유권에 기반을 둔 권한 관리를 이용하여 파일이나 디렉터리의 접근을 허가하거나 거부할 수 있게한다.
- 통신: 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 여러 상황이 있다. 이러한 통신을 수행하는 두 가지 중요한 방법이 있다. 첫번째는 동이ᅵᆯ한 컴퓨터에서 수행되고 있는 프로세스들 사이에서 일어나고, 두 번째는 컴퓨터 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템 상에서 수행되는 프로세스들 사이에서 일어난다. 통신은 공유 메모리를 통해서 구현될 수도 있고, 메시지 전달 기법에 의해 구현될 수 있는데, 후자의 경우 정보의 패킷들이 운영체제에 의해 프로세스들 사이를 이동한다.
- 오류 탐지: 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다. 오류는 CPU, 메모리 하드웨어, 입출력 장치, 또는 사용자 프로그램에서 일어날 수 있다. 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조치를 취해야 한다. 물론 운영체제가 오류에 어떻게 반응하며 수정하는 가에 다양한 변종이 존재한다. 디버깅 설비는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상시킨다.
- 자원 할당: 다수의 사용자나 다수의 작업들이 동시에 실행될 때, 그들 각각에 자원을 할당해 주어야 한다. 운영체제는 여러 가지 다른 종류의 자원을 관리한다. 어떤 것들은 특수한 할당 코드를 가질 수 있는 반면, 다른 것들은 훨씬 일반적인 요청과 방출 코드를 가질 수 있다. 예를 들면 CPU를 최대한 효율적으로 이용하기 위해 운영체제는 CPU 스케줄링 루틴이 CPU의 속도, 반드시 실행해야 할 작업들, 사용 가능한 레지스터의 수와 다른 요인들을 고려하도록 해야 한다. 또한 프린터, USB 저장장치 드ㅏㄹ이브 및 다른 주변 장치를 할당하는 루틴이 있을 수 있다.
- 회계: 우리는 사용자가 어떤 종류의 첨퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있기를 원한다. 이와 같은 기록 관리는 회계, 또는 단순히 사용 통계를 내기 위해 사용된다. 사용 통계는 컴퓨팅 서비스를 개선하기 위해 시스템을 재구성하고자 하는 연구자에게 귀중한 자료가 될 수 있다.
- 보호와 보안: 다중 사용자 컴퓨터 시스템 또는 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원한다. 서로 다른 여러 프로세스가 병행하게 수행될 때 한 프로세스가 다른 프로세스나 운영체제 자체를 방해해서는 안 된다. 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. 외부로부터의 시스템 보안 또한 중요하다. 이러한 보안은 각 사용자가 자원에 대한 접근 을 원할 때 통상 패스워드를 사용해서 시스템에게 자기 자신을 인증하는 것으로부터 시작된다. 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고 침입의 탐지를 우ㅣ해 모든 접속을 기록하는 것으로 범위를 넓힌다. 만약 시스템이 보호되고 보안이 유지되려면, 시스템 전체에 걸쳐 예방책이 제정되어야 한다. 하나의 사슬은 가장 약한 연결 고리만큼만 강한 법이다.


# 2.2 사용자 운영체제 인터페이스
## 2.2.1 명령해석기(Command-Interpreter)
- 어떤 운영체제는 커널에 명령 해석기를 포함하고 있다. Windows와 UNIX같은 다른 운영체제는 명령 해석기를 작업이 시작되거나, 사용자가 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다. 선택할 수 있는 여러 명령어 해석기를 제공하는 시스템에서 이 해석기는 셸(shell)이라고 블린다.
- 명령어 해석기의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 이 수준에서 제공된 많은 명령들은 파일을 조작한다. 즉 생성, 삭제, 리스트, 프린트, 복사, 수행 등을 한다. 이 명령어들은 두가지 일반적인 방식으로 구현될 수 있다.
- 한가지 방법은 명령 해석기 자체가 명령을 실행할 코드를 갖고 있는 경우이다. 예를 들면 한 파일을 삭제하기 위한 명령은 명령 해석기가 자신의 코드의 한 부분으로 분기하고, 그 코드 부분이 매개변수를 설정하고 적절한 시스템 호출을 한다. 이 경우 제공될 수 있는 명령의 수가 명령 해석기의 크기를 결정하는데 그 이유는 각 명령이 자신의 쿠현 코드를 요구하기 때문이다.
- 여러 운영체제중 UNIX에 의해 사용되는 다른 대안의 접근 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다 
- 여러 운영체제 중 UNIX에 의해 사용되는 다른 대안의 접근 방법은, 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다. 이러한 경우 명령 해석기는 전혀 그 명령을 알지 못한다. 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다. 따라서 파일을 삭제하는 다음의 UNIX 명령 rm 은 파일을 챃아서, 메로리에 적재하고 수행한다. rm 명령과 관련된 기능은 rm이라는 파일 내의 코드로 완전하게 정의된다. 이러한 방법으로, 프로그래머는 적합한 이름을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수 있다. 명령 해석기 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없다.

## 2.2.2 그래피컬 사용자 인터페이스(graphical User Interface)
- 운영체제와 접촉하는 두번째 방식은 사용자 친화적인 그래피컬 사용자 인터페이스 또는 GUI를 통하는 방식이다. 이 방식에서는 명령어 라인 인터페이스를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 데스크톱이라고 특징지어지는 마우스를 기반으로 하는 윈도우 메뉴시스템을 사용한다. 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의 이미지에 위치시킨다. 마우스 포인터의 위치에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나, 파일 혹은 디렉터리를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 잡아당길 수도 있다.
- 마우스는 대부분의 모바일 시스템에서 사용하기 어려운 장치이기 때문에 스마트폰이나 휴대형 태블릿 컴퓨터는 보통 터치스크린 인터페이스를 사용한다. 사용자들은 터치스크린 위에서 누르고 화면을 손가락으로 쓸거나 하는 등의 동작을 취함으로써 컴퓨터와 상호작용한다. 

## 2.2.3 인터페이스의 선택
- 명령어 라인 또는 그래피컬 인터페이스를 사용할 것인지는 개인의 선호에 달려있다
- 사용자 인터페이스는 시스템마다 심지어 한 시스템의 사용자마다 다를 수 있다. 통상 실제 시스템 구조에서는 지외되었다. 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것이 운영체제의 직접적인 기능은 아니다. 이 책에서는, 사용자 프로그램에 적절한 서비스를 제공하는데 있어서 근본적인 문제점들에 초점을 맞춘다. 우리는 사용자 프로그램과 시스템 프로그램을 구별하지 않는다.

# 2.3 시스템 호출(System Calls)
- 시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 특정 저수준은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C++ 언어로 작성된 루틴 형태로 제공된다.
- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하게 된다. 종종 초당 수천 개의 시스템 호출을 수행하게 된다. 대부분의 사용자들은 이러한 정도의 상세를 겹코 알지 못한다. 대부분의 응용 개발자들은 API에 따라 프로그램을 설계한다. 
- API를 따라 개발하는데에는 여러가지 이점이 있다. 그중 하나는 호환성이다. API에 따라 프로그램을 설계 하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고 실행 된다는 것으 길대할 수 있다.
- 프로그래밍 언어들을 위한 실행시간 지원 시스템은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템호출 인터페이스를 제공한다. 이 시스템 호출 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 호출을 부른다. 통상 각 시스템 호출에는 번호가 할당되고 시스템 호출 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 호출 인터페이스는 의도하는 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다.
- 호출자는 시스템 호출이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다. 호출자는 단지 API를 준수하고 시스템 호출의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다. 따라서 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 실행시간 지원 라이브러리에 의해 관리된다. (p74 그림 참조)
- 시스템 호출은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다. 종종, 단순히 원하는 시스템 호출이 무엇인지보다 더 많은 정보가 요구될 경우도 입닸. 필요한 정보ㅇ 유형과 양은 특정 운영체제와 호출에 따라 다양하다. 예를 들면 입력을 받아 들이기 위해 입력원으로 사용ᅬᆯ 파일이나 장치와 함께 읽어 들인 데이터를 저장할 메모리 버퍼의 주소와 길이를 명시할 필요가 있다. 물론 장치나 파일 그리고 길이는 시스템 호출에 암묵적일 수 있다.
- 운영체제에 매개변수를 전달하기 위해서 세 가지 일반적인 방법을 사용한다. 가장 간단한 방법은 매개 변수를 레지스터 내에 전달하는 것이다. 그러나 어떤 경우는 레지스터보다 더 많은 매개변수가 있을 수 있다. 이러한 경우에 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개 변수로 전달된다. 매개변수는 프로그램에 의해 스택에 넣어질 수 있고, 운영체제에 의해 꺼내진다. 몇몇 운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다. 

# 2.4 시스템 호출의 유형
- 시스템 호출은 다섯 가지의 중요한 범주 즉, 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등으로 묶을 수 있다.
  - 프로세스 제어
    - 끝내기, 중지
    - 적재, 수행
    - 프로세스 생성, 프로세스 종료
    - 프로세스 속성 흭득, 프로세스 속성 설정
    - 시간을 기다
    - 사건을 기다림, 사건을 알림
    - 메모리 할당 및 자유
  - 파일 조작
    - 파일 생성, 파일 삭제 
    - 열기, 닫기 
    - 읽기, 쓰기, 위치 변경 
    - 파일 속성 흭득 및 설정 
  - 장치 관리 
    - 장치를 요구, 장치를 방출
    - 읽기, 쓰기, 위치 변경
    - 장치 속성 흭득, 장치 속성 설정 
    - 장치의 논리적 부착 또는 분리
  - 정보 유지 
    - 시간과 날짜의 설정과 희득
    - 시스템 데이터의 설정과 흭득 
    - 프로세스, 파일, 장치 속성의 흭득
    - 프로세스, 파일, 장치 속성의 설정
  - 통신 
    - 통신 연결의 생성, 제고 
    - 메시지의 송신, 수신 
    - 상태 정보 전달 
    - 원격 장치의 부착 및 분리 

## 2.4.1 프로세스 제어
- 실행 중인 프로그램은 수행을 정상적으로 또는 비정상적으로 멈출 수 있어야 한다. 만약 현재 실행중인 프로그램을 비정상적으로 중지하기 위해 시스템 호출이 행해지거나 또는, 프로그램에 문제가 발생해 오류 트랩을 유발할 경우, 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다. 
- 정상이거나 비정상인 상황에서, 운영체제는 명령 해석기로 제어르 절단핼야 한다. 명령 해석기는 이어 다음 명령을 읽는다. 대화식 시스템에서 명령 해석기는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다. GUI 시스템에서는 팝업 윈도우가 사용자에게 오류를 알리고 지시를 기다린다. 일괄처리 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다. 
- 한 프로그램을 실행하고 있는 프로세스나 잡이 다른 프로그램을 적재하고 실행하기를 원할 수 있다. 이 기능은 명령 해석기가 사용자 명령, 마우스의 클릭 혹은, 일괄처리 명령 등을 통하여 지시된 프로그램을 실행하는 것을 허용한다. 여기서 흥미 있는 질문은 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐 하는 것이다 .이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련있다.
- 만약 새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다. 따라서 우리는 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다. 만약 두 프로그램이 병행하게 수행된다면, 우리는 다중 프로그래밍 될 새로운 잡이나 프로세스를 생성한 것이다.
- 만약 새로운 잡이나 프로세스 혹은, 잡들이나 프로세스들의 집합을 생성한다면, 그들의 실행을 제어할 수 있어야 한다. 이러한 제어는 잡의 우선순위, 최대 허용 실행 시간등을 포함하여 잡 혹은 프로세스ㅇ의 속성들을 결정하고 재설정할 수 있는 능력을 필요로 한다.
- 새로운 잡이나 프로세스를 생성한 후에는, 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다. 우리는 일정 시간만큼 기다리기를 원할 수 있다. 그리고 보다 가능성이 큰 경우는 우리가 특정 사건이 일어날 때까지 기다리는 것이다. 그 경우 잡이나 프로쎄드을ᅳᆫ 그 사건이 일어나면 신호를 보내야 한다.
- 둘 이상의 프로세스들은 데이터를 빈번하게 공유한다. 공유되는 데이터의 일관성을 보장하기 위해서는 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 호출을 제공한다. 그러면 잠금이 해제될 때까지 어느 프로세스도 데이터에 접근할 수 없게 된다. 통상 그런 시스템은 acquire_lock()과 release_lock() 시스템 호출을 제공한다. 
- 프로세스 잡 제어는 너무 많은 측면과 다양성이 있기 때문에, 이러한 개념들을 명확히 하기 위해 단일 태스킹 시스템과 다중 태스킹 시스템의 두 예를 사용한다.
- MS-DOS 운영체제는 단일 태스킹 시스템의 예로, 컴퓨터가 시동될 때 호출되는 하나의 명령 해석기를 가진다. 단일 태스킹이기 때문에, 하나의 프로그램을 수행하기 위해 간단한 방법을 사용하며, 새로운 프로세스를 생성하지 않는다. 프로그램을 메모리에 적재하며, 이 때 가능한 한 많은 메모리를 프로그램에 제공하기 위해 자신의 대부분을 덮어 쓴다. 이어 명령 포인터를 프로그램의 첫 번째 명령으로 설정한다. 그 다음 프로그램이 수행되며, 오류가 있을 경우는 트랩이 발생되거나, 아니면 종료를 위해 시스템 호출을 수행한다. 어느 경우든, 다음에 이용하기 위해 오류 코드가 시스템 메모리에 저장된다. 이 동작에 이어, 명령 해석기의 덮어 씨이지 않은 적은 부분이 실행을 재개한다. 이것의 첫 번째 일은 명령 해석기의 나머지를 디스크로부터 다시 적재하는 것이다. 이 일이 수행되면, 명령 해석기는 앞의 오류 코드를 사용자나 다음 프로그램이 사용할 수 있게 해준다.
- FREEBSD는 다중 태스킹 시스템의 예이다. 사용자가 시스템에 로그인할 때 사용자가 선택한 쉘이 수행된다. 이 쉘은 명령을 받아서 사용자가 요청한 프로그램을 수행한다는 점에서 MS-DOS명령 해석기와 유사하다. 하지만 FreeBSD는 다중 태스킹 시스템이기 때문에 명령 해석기는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있다. 새로운 프로세스를 시작하기 위해 쉘은 fork() 시스템 호출을 실행한다. 그런 다음, 선택된 프로그램이 exec()시스템 호출을 통해 메모리에 적재되고, 이어 그 다음 프로그램이 수행된다. 명령이 내려진 방법에 따라, 쉘은 프로세스가 종료하기를 기다리거나 백그라운드에서 프로세스를 수행한다. 후자의 경우 쉘은 바로 또 다른 명령을 요청한다. 프로세스가 백그라운드에서 수행될 때, 그 프로세스는 키보드로 부터 직접 입력을 받을 수 없는데, 이는 쉘이 그 자원을 사용하고 있기 때문이다. 따라서 입출력은 파일, 또는 GUI를 통해 행해진다. 반면에 사용자는 쉘에게 다른 프로그램을 수행하도록 요청하거나, 수행중인 프로세스의 진행사항을 감시하게 하거나, 그 프로그램의 우선순위를 변경하는 등의 요청을 자유롭게 합 수 있다. 프로세스가 끝나면, 종료하기 위해 exit() 시스템 호출을 수행하며, 호출한 프로세스에게 상태 코드 0 을 돌려주거나 0이 아닌 오류코드를 돌려준다. 이러한 상태 또는 오류 코드는 쉘 또는 다른 프로그램들이 이용할 수 있게 된다.

## 2.4.2 파일관리
- 파일 시스템이 파일을 조직하기 위해 디렉터리 구조를 가진다면, 우리는 디렉터리에 대해서도 이와 같은 연산 집합이 필요할 것이다. 추가로, 파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수 있어야 하고, 필요하다면 그것을 재설정 할 수 있어야 한다. 파일 속성은 파일 이름 파일 타입,  보호 코드, 회계 정보 등을 포함한다. 이러한 기능을 위해서는 최소한 파일 속성 흭득과 파일 속성 설정의 두 시스템 호출이 필요하다. 몇몇 운영체제는 파일 이동과 복사 등의 훨씬 더 많은 시스템 호출들을 제공한다. 일부 시스템들은 코드와 다른 시스템 호출을 이용하여 동일한 작업을 수행하는 API를 제공할 수도 있고 일부 시스템은 단순히 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 한다. 만일 이 시스템 프로그램이 다른 프로그램에 의해 호출 가능하다면 프로그램의 입장에서는 이 시스템 프로그램이 API가 된다.

## 2.4.3 장치 관리
- 프로세스는 작업을 계속 수행하기 위해 추가 자원을 필요로 할 수 있다. 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에 접근 등이 될 수 있다. 만약 자원들을 사용할 수 있다면ㅇ, 이들 자원이 주어지고, 제어가 사용자 프로그램으로 복귀될 수 있다. 그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.
- 운영체제에 의해 제어되는 다양한 자원들은 장치로 간줄될 수 있다. 이 장치들의 일부는 물리장치이고 다른 장치들은 추상적 혹은, 가상적 장치로 생각할 수 있다. 다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 우선 그 장치를 요청하는 것을 요구한다. 그 장치의 사용이 끝나면 우리는 그것을 반드시 방출해야 한다. 이러한 기능은 파일의 열기 닫기 시스템 호출과 비슷하다. 다른 운영체제들은 장치에 대해 통제되지 않은 접근을 허용한다. 
- 일단 장치를 요청하고, 파일에서와 같이 그 장치를 읽고, 쓰고 , 위치를 변경할 수 도 있다. 사실 입출력 장치와 파일들 간에는 유사성이 매우 많기 때문에, UNIX를 포함한 많은 운영체제가 이들 둘을 통합된 파일-장치 구조로 결합하였다. 이 경우 같은 시스템 호출들이 파일과 장치에 대해 사용된다 때로 입출력 장치들은 특별한 파일 이름, 디렉터리 배치 또는 파일 속성으로 식별된다.  

## 2.4.4 정보의 유지
- 많은 시스템 호출은 단순히 사용자 프로그램과 운운영체제간의 정보 전달을 위해 존재한다. 예를 들면 대부분의 시스템은 현재 시간과 날짜를 되돌려 주는 시스템 호출을 가지고 있다. 다른 시스템 호출은 현재 사용자 수, 운영체제의 버전 번호, 자유 메모리 또는 자유 디스크 공간등과 같은 시스템에 관한 정보를 알려준다.
- 시스템 호출들의 또 다른 집합은 프로그램을 디버깅하는데 유용하다. 많은 시스템들은 메모리를 덤프하기 위한 시스템 호출을 제공하며, 이것은 디버깅하는 데 유용하다. 프로그램 추적은 각 명령어가 실행될 때 이들을 하나씩 나열하며, 이러한 시스템 호출은 보다 소수의 시스템에서만 제공된다. 심지어 마이크로 프로세서들도 단일단계라고 알려진 CPU모드를 제공하는데, 매번 명령어 수행 후 CPU에 의해 트랩이 수행된다. 트랩은 통상 디버거에 의해 포착된다.
- 많은 운영체제는 프로그램의 시간 프로파일을 제공한다. 시간 프로파일은 그 프로그램이 특정 위치 혹은, 위치의 집합에서 수행한 시간의 양을 나타낸다 시간 프로파일은 추적 설비나 정규 타이머 인터럽트를 필요로 한다. 타이머 인터럽트가 발생할 때마다, 프로그램 카운터의 값이 기록된다. 따라서 타이머 인터럽트가 충분히 빈번하게 일어나면, 프로그램 카운터의 값이 기록된다. 따라서 타이머 인터럽트가 충분히 빈번하게 일어나면 프로그램의 여러 부분에서 소비한 시간의 통계적 그림을 얻을 수 있다. 

## 2.4.5 통신
- 통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다. 메시지 전달 모델에서는 통신하는 두 프로세스가 정보를 교환하기 위하여 서로 메시지를 주고받는다. 메시지는 두 프로세스 사이에 직접 교환되거나 우편함을 통하여 간접적으로 교환될 수 있다.
- 통신이 이루어지기 전에 연결이 반드시 열려야 한다. 상대 통신자가 동일한 CPU에 있는 프로세스이든지 또는 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스이든지 간에 그 이름을 반드시 알고 있어야 한다. 상대 통신자가 동일 통신이 이루어지 전에 연결이 반드시 열려야 한다. 
- 네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 컴퓨터는 이들 이름으로 일반적으로 알려져 있다. 마찬가지로, 각 프로세스는 프로세스 이름을 가지고 있으며, 이 이름은 운영체제에 의해 동등한 식별자로 변환되고, 이 식별자는 운영체제가 그 프로세스를 가리키는 데 사용할 수 있다. 
- get_hostid()와 get_processid() 시스템 호출은 이러한 변환을 수행한다. 이들 식별자는 그 후 시스템의 통신 모델에 따라 파일 시스템에 의해 제공되는 범용의 open과 close 호출에 전달되거나, 특정 open_connection()과 close_connection() 호출에 자신의 허가를 제공한다. 연결을 받아들일 프로세스들의 대부분은 특수 목적의 디먼으로서 이들은 그러한 목적을 위해 제공된 시스템 프로그램들이다. 그들은 연결을 위해 대기 호출을 수행하고 연결이 이루어질 때 깨어난다. 클라이언트로 알리진 통신의 출발지와 서버로 알려진 수신 디먼은 이어 read_message()와 write_message() 시스템 호출에 의해 메시지들을 교환한다. close_connection() 호출은 통신을 종료한다.
- 공유 메모리 모델에서, 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 share_memory_create()와 shared_memory_attach() 시스템템 호출을 사용한다. 정상적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리를 접근하는 것을 막으려고 한다는 것을 기억하라. 공유 메모리는 두 개 이상의 프로세스가 이러한 제한을 제거하는 데 동의할 것을 필요로 한다. 그런 후, 이들 프로세스들은 이러한 공유 영역에서 데이터를 읽고 씀으로써 정보를 교환할 수 있다. 데이터의 형식은 운영체제의 제어 하에 있는 것이 아니라 이들 프로세스들에 의해 결정된다. 프로세스들은 또한 동일한 위치에 동시에 쓰지 않도록 보장할 책임을 가진다.
- 이러한 두 가지 방법은 운영체제에서 보편적이며, 대부분의 시스템들은 둘 다 구현한다. 메시지 전달은 소량의 데이터를 교환할 때 유용한데, 이는 피해야 할 충돌이 없기 때문이다. 메시지 전달은 또한 컴퓨터간의 통신을 위해 메모리 공유보다 구현하기가 쉽다 공유 메모리는 한 컴퓨터 안에서는 메모리 전송 속도로 수행할 수 있기 때문에 최대 속도와 편리한 통신을 허용한다. 

## 2.4.6 보호(Protection)
보호는 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다. 역사억르ㅗ 보호는 다수의 사용자를 가지는 다중프로그램 시스템에서만 고려되는 문제였다. 그러나 네트워킹과 인터넷의 출현으로 서버에서 휴대용 컴퓨터까지 모든 컴퓨터 시스템에서 보호를 고려하여야 한다.
통상 보호를 지원하는 시스템 호출은 set_permission() 과 get_permission()을 포함하는 데, 파일과 디스크와 같은 자원의 허가 권한을 설정하는 데 이용된다. allow_user()와 deny_user() 시스템 호출은 특정 사용자가 지정된 자원에 대해 접근이 허가 혹은 불허 되어있는지의 여부를 명시한다.

# 2.5 시스템 프로그램
- 시스템 프로그램은, 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 보다 편리한 환경을 제공한다. 그들 중 몇몇은 단순히 시스템 호출에 대한 사용자 인터페이스이며, 반면에 나머지는 훨씬 더 복잡하다.
  -  파일 관리: 이들 프로그램은 파일과 디렉터리를 생성, 삭제, 복사, 개명, 인쇄, 덤프, 리스트하고, 기본적인 조작을 한다.
  -  상태 정보: 어떤 프로그램들은 단순히 시스템에게 날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수 혹은 이와 비슷한 상태 정보를 묻는다. 다른 프로그램들은 더 복잡하여 상세한 성능, 로깅 및 디버깅 정보를 제공한다. 통상 이 프로그램들은 정보를 단말기나 다른 출력 장치 혹은 파일로 포맷하여 인쇄하거나 또는 GUI의 윈도우에 표시한다. 몇몇 시스템은 환경 설정 정보를 저장하고 검색할 수 있는 등록 기능을 지원하기도 한다.
  -  파일 변경: 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 다수의 문서 편집기가 사용 가능하다. 파일의 내용을 검색하거나 변환하기 위한 특수 명령어가 제공되기도 한다.
  -  프로그래밍언어지원: 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운로드 받을 수 있다.
  -  프로그램 적재와 수행: 일단 프로그램이 어셈블 되거나 컴파일 된 후, 그것이 수행되려면 반드시 메모리에 적재 되어야 한다. 시스템은 절대 로더, 재배치 가능 로더, ㄹ딩키지 에디터와 중첩 로더 등을 제공할 수 있다. 또한 고급어나 기계어를 위한 디버깅 시스템도 필요하다.
  -  통신: 이들 프로그램은 프로세스, 사용자, 그리고 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 지공한다. 이들 프로그램은 사용자가 다른 사용자 화면으로 메시지를 전송하거나, 웹 페이지를 옮겨 다니거나, 이메일을 보내거나, 한 기계에서 다른 기계로 파일을 전송할 수 있게 한다.
  -  백그라운드 서비스: 모든 범용 시스템은 부팅할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다. 이러한 프로세스 중 일부는 자신들의 할 일을 완수하면 종료하는 반면에 일부는 시스템이 정지될 때까지 계속해서 실행되는 프로세스도 존재한다. 항상 실행되는 시스템 프로그램 프로세스는 서비스, 서브시스템, 또는 디먼으로 알려져 있다. 이 예에서 시스템은 연결 요청을 올바른 프로세스에게 연결해 주기 위하여 네트워크 연결을 청취하는 서비스가 필요하였다. 또 다른 예로 지정된 스케줄에 따라 프로세스를 시작시키는 프로세스 스케줄러, 시스템 오류감시 서비스 및 출력 서버를 들 수 있다. 전형적인 시스템은 수십개의 디먼을 가지고 있다. 게다가 운영체제가 중요한 활동을 커널 문맥에서가 아니라 사용자 문맥에서 실행해야 하는 경우, 디먼을 이용해서 이 작업을 수행할 수 있다.

- 대부분의 운영체제는 시스템 프로그램과 함께 일반적인 문제점을 해결하거나 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공한다.

# 2.6 운영체제 설계 및 구현
## 2.6.1 설계 목표
- 시스템을 설계하는 데에 첫째 문제점은 시스템의 목표와 명세를 정의하는 일이다. 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 타입의 선택에 의해 영향을 받을 것이다.
- 이 최상위 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 훨씬 어려워진다. 그러나 이런 요구 조건은 근본적으로 사용자 목적과 시스템 목적의 두가지로 나뉜다.
- 사용자들이 시스템에 기대하는 특징들이 존재한다. 시스템은 사용하기 쉽고 편리하며, 배우기 쉽고 , 믿을 수 있고, 안전하고, 신속해야 한다. 물론 이러한 특징을 구현하는 방법에 대해 일반적으로 합의된 사항이 없기 때문에, 시스템을 설계할 때 이러한 명세가 쓸모 있지는 않다.
- 이와 유사한 요구 조건들이 시스템을 설계, 생성, 유지, 조작해야 하는 사람들에 의해 정의될 수 있다. 즉, 운영체제는 설계, 구현, 유지 보수가 쉬워야 하며, 또한 적응성, 신뢰성 무오류, 효율성을 가져야 한다. 
- 요약하면 운영체제에 대한 요구를 정의하는 문제를 해결하는 유일한 해법은 없다.
- 운영체제의 명세와 설계는 매우 창조적인 일이다. 어떤 교재도 이런 문제점을 해결하는 방법을 알려 줄수는 없지만, 소프트웨어 공학 분야에 의해 개발된, 특별히 운영체제에 적용 가능한 일반적인 원칙들이 존재한다.

## 2.6.2 기법과 정책
- 한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다. 기법은 어떤 일을 어떻게 할 것인가를 결정하는 것이고, 정책은 무엇을 할 것인가를 결정하는 것이다. 예를 들면 타이머 구조는 CPU 보호를 보장하기 위한 기법이지만, 특정 사용자를 위해 타이머를 얼마나 오랫동한 설정할지를 결정하는 것은 정책적 결정이다.
- 정책과 기법의 분리는 융통성을 위해 아주 중요하다. 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있다. 최악의 경우, 정책의 각 변경이 저변에 깔려 있는 기법의 변경을 요구하게 된다. 정책의 변경에 민감하지 않은 일반적인 기법이 보다 바람직하다. 그렇게 되면 정책의 변경은 시스템의 일부 매개변수만을 재정의 하도록 요구한다.
- 마이크로 커널 기반 운영체제는 원시 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다. 이 블록들은 정책으로부터 거의 자유로우며, 보다 고급의 기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다. 
- 정책 결정은 모든 자원 할당 문제에 있어 중요하다. 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야한다. 질문이 무엇이 아니라 어떻게 일 때마다, 반드시 결정되어야 하는 것은 기법이다.

## 2.6.3 구현
- 운영체제의 설계가 완료되면 구현되어야 한다. 운영체제는 많은 사람들에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에 구현 방법에 대해 일반적인 언급을 하는 것은 어렵다.
- 초창기 운영체제는 어셈블리어로 작성되었다. 어셈블리어로 작성된 운영체제가 존재하기는 하지만 대부분의 운영체제는 C와 같은 고급언어나 C++와 같은 더 고수준의 언어로 작성된다. 사실 운영체제는 하나 이상의 언어로 구현될 수도 있다. 
- 운영체제를 구현하기 위해 고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점은 그 언어가 응용 프로그램을 위해 사용될 때 생기는 장점과 마찬가지이다. 즉, 코드를 빨리 작성할 수 있으며, 더욱 간결하고, 이해하기 쉽고, 디버그하기도 쉽다. 추가로, 컴파일러 기술의 향상은, 단순하 재 컴파일에 의해 전체 운영체제를 위해 생성된 코드를 향상 시킬 것이다. 마지막으로 운영체제가 고급 수준 언어로 작성되었을 경우 이식이 훨씬 쉽다.
- 운영체제를 고급 수준 언어로 구현하는 것에 대해 주로 주장되는 단점은 속도가 느리고 저장 장치가 많이 소요되는 것이다. 그러나 이것은 현재의 시스템에서는 더 이상 주된 문제가 아니다. 전문적인 어셈블리어 프로그래머는 효율적인 작은 루틴을 생산할 수 있지만 현대의 컴파일러는 대규모 프로그램을 위해 복잡한 분석을 수행하고 그리고 정교한 최적화를 적용하여 우수한 코드를 생산할 수 있다. 현재의 처리기는 깊은 파이프라이닝과 다수의 기능 장치를 가지며 이들 기능 장치는 인간이 할 수 있는 것보다 훨씬 쉽게 복잡한 의존성의 상세 사항들을 처리할 수 있다.
- 다른 시스템에서도 알려진 사실이지만, 운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료 구조와 알고리즘의 결과일 가능성이 크다. 게다가 운영체제가 크긴 하지만, 단지 소량의 코드만이 고성능이 중ㅇ 효다ㅏ. 아마도 인터럽트 핸들러, 입출력 관리자, 메모리 관리자와 CPU 스케줄러가 가장 긴급한 루틴일 것이다. 시스템이 작성되어 정확히 작동하면, 병목 루틴을 확인할 수 있고, 동등한 어셈블리어로 대체될 수 있다.

# 2.7 운영체제 구조
- 현대의 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 한다. 일반적인 접근 방법은 한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분할하는 것이다. 이들 모듈들 각각은 신중히 정의된 입력, 출력, 그리고 기능들을 가진, 시스템의 잘 정의된 부분이라야한다.

## 2.7.1 간단한 구조
- 잘 정의된 구조를 갖지 못한 상용 운영체제가 많이 있다. 그러한 운영체제는 종종 처음에는 소형이면서 간단하고 제한된 시스템으로 시작되었지만, 원래의 범위 이상으로 발전된 것을이다. 그런 시스템의 예로 MS-DOS가 있다. MS-DOS는 원래 단지 몇 사람들에 의해서 설계, 구현되었고, 이들은 MS-DOS가 그렇게 대중화되리라고는 생각지 못했다. 그것은 최소의 공간에 최대의 기능들을 제공하도록 구현되었기 때문에 신중하게 모듈별로 구분되지 않았다.
- MS-DOS는 인터페이스와 기능 계층이 잘 분리되어 있지 않다. 예를 들면 응용 프로그램은 기본 입출력 루틴을 통하여 디스플레이와 디스크 드라이브에 직접 쓰기가 가능하다. 이러한 자유는 MS-DOS를 오류가 있는 프로그램으로부터 취약하게 만들었다. 따라서 사용자 프로그램이 고장 나면 시스템 전체가 고장 나게 된다.
- 물론 MS DOS 는 시작부터 하드웨어의 기능에 제한적이었다. 대상을로 하는 Intel 8088 이 이중 모드와 하드 웨어 보호기능을 제공히지 않기 때문에 MS-DOS의 설계자들은 기본적인 하드웨어를 접근하게 할 수 밝에 없었다. 
- 제한적인 구조의 또 다른 예는 최초의 UNIX 운영체제이다. MS-DOS와 마찬가지로 UNIX는 처음에는 하드웨어 기능에 의해 제한 받는 또 다른 시스템이 있다. UNIX는 두 부분, 커널과 시스템 프로그램으로 구성되어 있다. 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데, 이들은 UNIX가 발전해 오면서 여러해동안 추가되고 확장된 것이다. 
- 시스템 호출 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널이다. 커널은 시스템 호출을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공한다. 전체를 감안하면, 그것은 하나의 계층으로 결합하기에는 엄처나게 많은 기능이다. 이 모놀리식 구조는 구현하기 어렵고 또 유지 보수하기도 어려웠다. 그러나 이 구조는 성능 측면에서는 분명히 장점을 가지는 구조이다. 시스템 호출 인터페이스나 커널 안에서 통신하는 경우에는 오버헤드가 의 없다 우리는 이러한 간단하고 모놀리식 구조의 흔적을 여전히 UNIX, LINUX, 및 Windows 운영체제에서 발견할 수 있다.

## 2.7.2 계층적 접근
- 적절한 하드웨어 지원이 있을 경우, 운영체제는 원래의 MS-DOS 또는 UNIX시스템에 의해 허용되던 것보다 작고 보다 적절한 조각으로 분할될 수 있다. 운영체제는 컴퓨터와 그 컴퓨터를 사용하는 응용에 대해 훨씬 더 큰 제어를 유지할 수 있다. 구현자들은 시스템의 내부 동작,과 모듈식 운영체제의 생성에 변화를 줄 수 있는 보다 큰 자유를 갖게 되었다. 하향식 접근법 하에서는, 전체적인 기능과 특징이 결정되고 그리고 구성요소로 분리 된다 정보의 은폐 또한 중요하다. 프로그래머가 저수준 루틴을, 그 루틴의 외부 인터페이스가 변경되지 않고 그리고 루틴 자체가 공시된 일을 수행한다면, 그들이 적절하다고 생각하는 대로 자유스럽게 구현할 수 있게 하기 때문이다.
- 시스템은 다양한 방식으로 모듈화 될 수 있다. 한 가지 방식이 계층적 접근 방식인데 이 방식에서는 운영체제가 여러 개의 층으로 나누어 진다. 최하위 층은 하드웨어이고 최상위 층은 사용자 인터페이스이다. 
- 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다. 전형적인 운영체제층은 자료 구조와 상위 층에서 호출할 수 있는 루틴의 집합으로 구성된다.
- 계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다. 층들은 단지 자신의 하위 층들의 서비스와 기능들만을 사용하도록 선택된다. 이러한 접근 방법은 시스템의 검증과 디버깅 작업을 단순화한다. 첫 번째 층은 정의에 의해 하드웨어만을 사용하여 이 층의 기능을 구현하기 때문에, 나머지 시스템에 아무런 신경을 쓰지 않고 디버깅할 수 있다. 첫 번째 층의 디버깅이 끝나면, 두번째 층을 디버깅하는 동안 그것이 정확하게 동작한다고 가정될 수 있으며, 이러한 과정이 반복된다 만일 어느층의 디버깅중 오류가 발견되면 그 하위의 층은 이미 디버깅되었기 때문에 오류는 반드시 그층에 있다. 따라서 시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해진다.
- 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해 구현한다. 한 층은 이러한 연산들이 어떻게 구현되는지 알 필요가 없고, 다만 이러한 연산들이 무엇을 하는지만 알면된다. 그러므로 각 층은 특정 데이터 구조, 연산, 그리고 하드웨어ㅇ의 존재를 상위 층에 대해 숨기게 됬다.
- 계층적 접근 방법의 가장 어려운 점은 여러 층을 적절히 정의하는 것을 포함한다. 각 층은 자신의 하위에 있는 계층들만 사용할 수 있기 때문에 신중한 계획이 필요하다. 예를 들면 예비 저장 장치를 위한 장치 드라이버는, 메모리 관리가 예비 저장 장치를 사용할 수 있는 능력을 필요로 하기 때문에 메모리 관리 루틴들보다 하위 층에 있어야 한다.
- 다른 요구 조건들은 그렇게 명확하지는 않다 예비 저장 장치 드라이버는 통상적으로 CPU 스케줄러 위에 존재하는데, 이는 드라이버가 입출력을 위해 기다려야 하고, CPU가 그 동안 재스케줄될 수 있기 때문이다. 그러나 대형 시스템의 CPU 스케줄러는 활동중인 모든 프로세스들에 대해 메모리에 적재할 수 있는 것보다 더 많은 정보를 가질수 있다. 따라서 이러한 정보들은 메모리에 스왑인 또는 스왑아웃될 필요가 있을 수 있으며, 이는 예비 저장 장치 드라이버 루틴이 CPU 스케줄러 아래에 놓일 것을 요구한다.
- 계층적 구현 방법의 마지막 문제점은 다른 유형의 구현 방법보다 효율성이 낮다는 것이다. 예를 들면 사용자 프로그램이 입출력 연산을 수행할 ㅅ경우, 프로그램이 시스템 호출을 수행하여 입출력 층으로 트랩되고, 입출력 층은 메모리 관리 층을 호출하고, 메모리 관리 층은 이어 CPU 스케줄링 층을 호출하며, 마지막으로 하드웨어로 전달된다. 각 층에서, 매개 변수들이 변경된다든지, 데이터가 전달될 필요가 있다든지 하는 일이 있을 수 있다. 각 층은 시스템 호츨에 오버헤드를 추가하며, 그 결과 계층적 구조가 아닌 시스템보다 시스템 호출의 수행 시간이 더 오래 걸리게 된다.

## 2.7.3 마이크로커널
- UNIX가 확장함에 따라 커널이 커지고 관리하기 어려워진 것을 목격하였다. 연구자들은 마이크로커널 접근 방식을 사용하여 커널을 모듈화한 Mach라 불리는 운영체제를 개발하였다. 이방법은 모든 중요치 않은 구성 요소를 커널로부터 제고하고, 그들을 시스템 및 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. 결과는 보다 적은 커널이다. 어느 서비스가 커널에 남아 있어야하고, 어느 서비스가 사용자 공간에 구현되어야 할지에 대해서는 의견이 일치하지 않는다. 그러나 통상 마이크로커널은 통신 설비 외에 추가로 최소한의 프로세스와 메모리 관리를 제공한다.
- 마이크로커널의 주 기능은 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공하는 것이다. 통신은 메시지 전달에 의해 제공된다. 예를 들면 클라이언트 프로그램이 파일을 접근하기를 원하면, 파일 서버와 반드시 상호 작용해야 한다. 클라이언트 프로그램과 서비스는 결코 직접 상호 작용하지 않는다 오히려 그들은 마이크로 커널과 메시지를 교환함으로써 간접적으로 상호 작용한다.
- 마이크로 커널 접근법의 한 가지 장점은 운영체제의 확장이 용이하다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널의 변경을 필요로 하지 않는다. 커널이 변경되어야만 할 때는, 마이크로 커널이 작은 커널이기 때문에 변경할 대상이 비교적 적은 경향이 있다. 결과적으로 만들어지는 운영체제는 한 하드웨어로부터 다른 하드웨어로 이식이 쉽다 마이크로커널은 대부분의 서비스가 커널이 아니라 사용자 프로세스로 수행되기 때문에 보다 높은 보안성과 신뢰성을 제공한다. 만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 애마루ᅥᆫ 영향을 받지 않는다.
- 다수의 현대 운영체제가 마이크로ㅋ널 접근 방법을 사용하고 있다. Mach는 UNIX 시스템 호출을 적절한 사용자 수준 서비스에 대한 메시지로 사상한다. Darwin이라고 알려진 Mac OS X 커널도 Mach 마이크로커널에 기반을 두고 있다.
- 안타 깝게도 마이크로 커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다. Windows NT의 역사를 고려해 보자. 첫 번째 릴리즈는 계층적인 마이크로 커널 구조를 가졌다. 이 버전의 성능은 Windows 95에 비교될 정도로 성능이 떨어졌다. Windows NT 4.0은 계층들을 사용자 공간으로부터 커널 공간으로 옮기고 그들을 보다 긴밀히 통합함으로써 성능 문제를 부분적으로 개선 하였다. Windows 구조는 Windows XP가 설계될 때 까지 마이크로 커널보다는 모놀리식에 가까운 구조였다.

## 2.7.4 모듈
- 운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 아마도 적재가능 커널 모듈 기법의 사용일 것이다. 이 접근법에서는 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크한다. 이러한 유형의 설계는 현대 UNIX를 구현하는 일반적인 추세이다.
- 설계의 주안점은 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다. 서비스를 동적으로 링그하는 것은 새로운 기능을 직접 커널에 추가하는 것 보다 바람직하다. 후자의 경우 수정 사항이 생길 때마다 커널이 실행되는 동안 동적으로 구현하는 것이다. 서비스를 동적으로 링크하는 것은 새로운 기능을 직접 커널에 추가하는 것보다 바람직하다. 후자의 경우 수정 사항이 생길 때마다 커널을 다시 컴파일 해야 한다. 예를 들어 CPU 스케줄링과 메모리 관리 알고리즘은 커널에 직접 구현하고 다양한 파일 시스템을 지원하는 것은 적재가능 모듈을 통하여 구현할 수 있다.
- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다. 그러나 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다. 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는 지 안다는 점에서는 마이크로 커널과 유사하다. 그랴나 통신하기 위하여 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다.
- Solaris 운영체제 구조는 핵심커널과 7가지 유형의 적재가능 커널 모듈로 구성된다.
  1. 스케줄링 클래스
  2. 파일 시스
  3. 적재가능 시스템 호
  4. 실행파일 형
  5. STREAMS 모
  6. 기타 잡다한 기능
  7. 장치 및 버스 드라이
Linux도 장치드라이버와 파일 시스템을 지원하기 위하여 적재가능 커널 모듈을 사용한다. 이 장의 마지막에 있는 프로그래밍 연습문제에서 Linux에서 적재가능 커널 모듈을 만드는 실습을 제공한다.


