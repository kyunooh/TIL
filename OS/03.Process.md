# 3. 프로세스

- 초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용하였다. 이 프로그램이 시스템에 대한 완전한 제어를 가지고, 시스템의 모든 자원에 접근할 수 있었다. 반면 오늘 날의 컴퓨터 시스템들은 메모리에 다수의 프로그램들이 적재되어 병행 실행되는 것을 허용한다. 이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화할 것을 필요로 했다. 이러한 필요성이 프로세스의 개념을 낳았으며, 프로세스란 실행중인 프로그램을 말한다. 프로세스는 현대의 시분할 시스템에서 작업의 단위이다.
- 운영체제가 더욱 복잡해질수록, 사용자를 위해 보다 많은 기능이 기대된다. 비록 운영체제의 주관심은 사용자 프로그램을 실행하는 것이지만, 운영체제는 커널에 포함시키지 않는 편이 더 좋다고 판단된 다양한 시스템 작업들도 처리해야 한다. 그러므로 하나의 시스템은 프로세스들의 집합체이다. 즉, 운영체제 프로세스들은 시스템 코드를 실행하고 사용자 프로세스들은 사용자 코드를 실행한다. 이들 모든 프로세스들은 잠재적으로 병행 실행이 가능하고, CPU는 이들 프로세들 가운데서 다중화 된다. CPU를 각 프로세스들 사이에게 전환시킴으로써, 운영체제는 컴퓨터를 보다 생산적으로 만든ㅏ. 이장에서는 프로세스는 무엇이며, 어떻게 동작하는가를 논의한다.

## 3.1 프로세스 개념

- 우리가 운영체제를 논의할 때 한 가지 장애는 모든 CPU 활동들을 어떻게 부를 것인가 하는 데에 의문이 있다는 것이다. 일괄 처리 시스템은 잡들을 실행하는 반면에, 시분할 시스템은 사용자 프로그램 또는 태스크들을 가진다. 단일 사용자 시스템에서조차도 동시에 여러 프로그램들을 실행할 수 있다. 그리고 다중태스킹을 지원하지 않는 임베디드 장치 등에서 설혹 사용자가 한 번에 하나의 프로그램만 실행시키더라도, 운영체제는 메모리 관리와 같은 운영체제 내부의 예정된 활동들을 지원할 필요가 있다. 여러 가지 면에서 이들 모든 활동들은 유사하므로, 우리는 이들을 모두 프로세스라고 부른다. 
- 이 책에서는 잡과 프로세스란 용어를 거의 호환성 있게 사용한다. 우리는 개인적으로는 프레스라는 용어를 더 선호하지만, 운영체제의 많은 이론과 용어들은 운영체제의 중요한 활동이 잡 처리일 때 개발되었다. 단순히 프로세스라는 용어가 잡이라는 용어를 대체하였기 때문에 잡 스케줄링과 같이 잡이란 단어를 포함하는 일반적 용어의 사용을 피하는 것은 잘못된 일이다.

### 3.1.1 프로세스(The Process)

- 비공식 적으로, 프로세스란 실행중인 프로그램이다. 프로세스는 때로는 텍스트 섹션으로 알려진 프로그램 코드 이상의 무엇이다. 프로세스는 또한 프로그램 카운터의 값과 처리기 레지스터의 내용으로 대표되는 현재 활동을 포함한다. 프로세스는 일반적으로 함수의 매개변수, 복귀주소와 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

- 우리는 프로그램 그 자체는 프로세스가 아님을 강조한다. 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 수동적인 존재이다. 이와는 대조적으로 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재이다. 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다. 실행 파일을 메모리에 적재하는 일반적인 두 가지 방식은 실행 파일을 나타내는 아이콘을 더블 클릭하는 방식과 명령어 라인 상에서 prog.exe 또는 a.out과 같이 파일 이름을 입력하는 방식이다.

-  두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들은 두 개의 별도의 실행 순서로 간주된다. 예를 들어 여러 사용자가 메일 프로그램의 서로 다른 복사본을 실행하거나, 또는 동일 사용자가 웹 브라우저 프로그램의 여러 복사본을 호출할 수 있다. 이들 각각은 별도의 프로세스이며, 텍스트 섹션이 동등하다 할지라도 데이터, 힙 및 스택 섹션은 다를 수 있다. 프로세스가 실행되는 과정에서 많은 프로세스들을 생성하는 것이 보통이다.

- 프로세스 자체가 다른 개체를 위한 실행환경으로 동작할 수 있다는 사실에 주목하시오. Java 프로그래밍 환경이 좋은 예를 보인다. 대부분의 상황에서 실행가능한 Java 프로그램은 Java 가상기계 안에서 실행된다. JVM은 적재된 Java 코드를 해석하고 그 코드를 대신하여 원 기계어를 이용하여 행동을 취하는 프로세스로서 프로그램을 실행한다. 예를 들어 컴파일된 Java 프로그램 Program.class 를 실행하기 위해 다음과 같이 명령을 입력할 것이다. 

  `java program`

  Java 명령어는 JVM을 보통의 프로세스처럼 실행시키고, JVM은 Java 프로그램 Program을 가상기계 안에서 실행한다. 이 개념은 다른 기계어로 작성된 프로그램이 아니라 Java 언어로 작성된 프로그램을 실행시킨다는 점을 제외하면 모의실험과 동일한 개념이다.

### 3.1.2  프로세스 상태(Process State)

프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다. 프로세스는 다음 상태들 중 하나에 있게 된다.

- 새로운(new): 프로세스가 생성 중이다.
- 실행(running): 명령어들이 실행되고 있다.
- 대기(waiting): 프로세스가 어떤 사건이 일어나기를 기다린다.
- 준비 완료(ready): 프로세스가 처리기에 할당되기를 기다린다.
- 종료(terminated): 프로세스의 실행이 종료되었다.

이들 이름들은 임의적이고, 운영체제마다 변한다. 그렇지만 이들이 나타내는 상태들은 모든 시스템에서 찾아볼 수 있다. 또한 어떤 운영체제는 프로세스 상태를 더욱 자세하게 묘사하여 구별한다. 어느 한 순간에 한 처리기상에서는 오직 하나의 프로세스만이 실행된다는 것을 인식하는 것이 중요하다. 그렇지만 많은 프로세스가 준비완료 및 대기 상태에 있을 수 있다.



### 3.1.3 프로세스 제어 블록(Process Control Block)

각 프로세스는 운영체제에서 프로세스 제어 블록에 의해 표현된다. PCB를 나타낸다. 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.

- 프로세스 상태: 상태는 새로운, 준비 완료, 실행, 대기, 정지 상태 등이다.
- 프로그램 카운터: 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터들: CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 타입을 가진다. 레지스터 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드 정보가 포함된다. 프로그램 카운터와 함께 이 상태 정보는, 나중에 프로세스가 계속 올바르게 실행되도록 하기 위해서, 인터럽트 발생 시 저장되어야한다.
- CPU-스케줄링 정보: 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수들을 포함한다.
- 메모리 관리 정보: 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.
- 회계 정보: 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함한다.
- 입출력 상태 정보: 이 정보는 이 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

요야하면 프로세스 제어 블록은 단순하게는 프로세스마다 달라지는 모든 정보를 저장하는 저장소의 역할을 한다.

### 3.1.4 스레드(Threads)

이제 까지 논의한 프로세스 모델은 프로세스가 단일의 실행 스레드를 실행하는 프로그램임을 암시했다. 예를 들면 만일 한 스레드가 워드 프로세서 프로그램을 실행 중이면, 실행되는 명령어의 단일 스레드가 존재한다. 이 단일 제어 스레드는 프로세스로 하여금 한 번에 단지 한 가지 일만 실행하도록 허용한다. 예를 들면 사용자는 동일한 프로세스 내에서 문자를 입력하면서 동시에 철자 검사기를 실행할 수 없다. 대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 그들은 따라서 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다. 이러한 특성은 특히 다중처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행될수 있다. 스레드를 지원하는 시스템에서는 PCB는 각 스레드에 관한 정보를 포함하도록 확장된다. 스레드를 지원하기 위해서는 시스템 전반에 걸친 다른 수정도 필요하다.



##  3.2 프로세스 스케줄링

- 다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다. 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다. 이 목적을 달성하기 위해 프로세스 스케줄러는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택한다. 단일 처리기 시스템에서는 실행 중인 프로세스가 한 개 이상 있을 수 없다. 만일 프로세스들이 여러 개가 있다면, 나머지 프로세스들은 CPU가 자유로워 다시 스케줄 될 때까지 대기해야만 한다.

### 3.2.1 스케줄링 큐(Scheduling Queues)

- 프로세스가 시스템에 들어오면, 이들은 잡 큐에 놓여진다. 이 큐는 시스템 안의 모든 프로세스로 구성된다. 주 메모리에 존재하며, 준비 완료 상태에서 실행을 대기하는 프로세스들은 준비 완료 큐라 불리는 리스트 상에 유지된다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 완료 큐의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터를 포함한다. 각 PCB는 준비 완료 큐에 있는 다음 프로세스를 가리키는 포인터 필드를 가진다. 
- 시스템에는 또한 다른 큐들도 있다. 프로세스가 CPU를 할당받으면, 어느 정도 실행을 하고 결국에는 그만두거나, 인터럽트되거나, 입출력 요청이 완료되는 것 같은 특별한 사건의 발생을 기다리게 된다. 프로세스가 디스크 같은 공유 장치에 입출력 요청을 했다고 가정하자. 시스템에는 많은 프로세스들이 있기 때문에, 디스크가 다른 프로세스들의 입출력 요청으로 바쁠 수가 있다. 그러므로 프로세스는 디스크를 대기해야 할 수도 있다. 특정 입출력 장치를 대기하는 프로세스들의 리스트를 장치 큐라고 한다. 각 장치는 그 자신의 장치 큐를 가진다.
- 프로세스 스케줄링의 공통적인 표현 방식은 같은 큐잉 도표이다. 각 사각형은 하나의 큐를 나타낸다. 두 가지 타입의 큐가 존재한다. 원은 큐를 서비스하는 자원이며, 화살표는 시스템에서 프로세스들의 흐름을 표현한다. 
- 새로운 프로세스는 처음에 준비 완료 큐에 놓인다. 프로세스는 실행을 위하여 선택될 때 즉, CPU를 할당받을 때까지 준비 완료 큐에서 대기한다. 일단 프로세스에 CPU가 할당되어 실행되면, 여러 가지 사건들 중의 하나가 발생할 수 있다.
  - 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수 있다.
  - 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다.
  - 프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, 준비 완료 큐에 다시 놓일 수 있다.
- 처음의 두 경우에서, 프로세스는 결국 대기 상태에서 준비완료 상태로 전환되고, 다시 준비 완료 큐에 넣어지게 된다. 프로세스는 종료될 때까지 이 주기를 계속하며, 종료되면 모든 큐에서 삭제되고 그 자신의 PCB와 자원을 반납한다.

### 3.2.2 스케줄러(Schedulers)

- 프로세스는 일생 동안에 다양한 스케줄링 큐들 사이를 이주한다. 운영체제는 어떤 방식으로든지 스케줄링 목적을 위해 프로세스들을 이들 큐에서 반드시 선택해야 한다. 선택 절차는 적절한 스케줄러에 의하여 수행된다.
- 일괄처리 시스템에서는 즉시 실행될 수 있는 것보다 더 많은 프로세스들이 종종 제출된다. 이들 프로세스들은 대용량 메모리에 저장되어 나중에 실행될 때까지 그곳에 유지된다. 장기 스케줄러는 이 풀에서 프로세스들을 선택하여 실행하기 위해 메모리로 적재한다. 단기 스케줄러는 실행 준비가 완료되어 있는 프로세스들 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.
- 이들 두 스케줄러 사이의 주요한 차이점은 이들의 실행 빈도에 있다. 단기 스케줄러는 CPU를 위해 반드시 자주 새로운 프로세스를 선택해야 한다. 프로세스는 입출력 요청을 위해 대기하기 전까지 겨우 수 밀리초 동안 실행될 수 있다. 종종 단기 스케줄러는 매번 백 밀리초마다 최소한 한 번씩 실행된다. 실행 간격이 짧기 때문에, 단기 스케줄러는 반드시 매우 빨라야 한다. 만일 한 프레스스를 백 밀리초 동안 실행하이ㄱ 위하여 십 밀리초를 소모한다면 10/(100 + 10) = 9 퍼센트의 CPU를 단순히 작업을 스케줄링하기 위하여 사용(낭비)하게 된다.
- 장기 스케줄러는 실행 빈도수가 훨씬 적다. 시스템에서 새로운 프레스스를 생성하는 간격은 수 분이 될 수 있다. 다중 프로그래밍의 정도가 안정적이면, 평균 프로세스 생성ㄴ률이 시스템을 떠나는 평균 프로세스 이탈률과 반드시 동일해야 한다. 그러므로 장기 스케줄러는 프로세스가 시스템을 떠날 때만 호출 될 필요가 있을 수도 있다. 실행간격이 비교적 크기 때문에, 장기 스케줄러는 실행할 프로세스를 선택하는 데 시간을 더 사용해도 된다.
- 장기 스케줄러가 신중한 선택을 하는 것이 중요하다. 일반적으로, 대부분의 프로세스들은 입출력 중심 또는 CPU 중심으로 묘사된다. 입출력 중심 프로세스는 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스이다. 반면에, CPU 중심 프로세스는 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스이다. 장기 스케줄러는 입출력 중심과 CPU 중심 프로세스들의 적절한 프로세스 혼합을 선택하는 것이 중요하다. 만일 모든 프로세스들이 입출력 중심이라면, 준비 완료 큐는 항상 비게 되고, 단기 스케줄러는 할 일이 없게 된다. 모든 프로세스들이 CPU 중심이라면, 입출력 대기 큐는 항상 비어 있는 상태가 되고, 장치들이 사용되지 않을 것이고, 재차 시스템이 균형을 잃게 된다. 최선의 성능을 가진 시스템이 균형을 잃게 된다. 최선의 성능을 가진 시스템은 CPU 중심과 입출력 중심 프로세스들을 적절히 혼합한다.
- 어떤 시스템에서는 장기 스케줄러가 없거나 기능이 적다. 예를 들어 UNIX와 Microsoft Windows 같은 시분할 시스템들은 장기 스케줄러가 없으며, 모든 새로운 프로세스를 단기 스케줄러를 위하여 단순히 메모리에 넣는다. 이들 시스템들의 안정성은 물리적인 제한이나 사용자들의 자체 조정 본능에 의존한다. 성능이 수용할 수 없을 정도로 저하되면, 어떤 사용자들은 단순히 그만 둘 것이다.
- 시분할 시스템과 같은 일부 운영체제들은 추가로 중간 수준의 스케줄링을 도입한다. 중기 스케줄러의 핵심 아이디어는 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍의 정도를 완화하는 것이 가끔 바람직할 수 있다는 것이다. 차후에 다시 프로세스를 메모리로 불러와서 중단되었던 지점에서부터 실행을 재개한다. 이러한 기법을 스와핑이라고 한다. 프로세스는 중기 스케줄러에 의하여 스왑되어 나가고 후에 다시 스왑되어 들어온다. 스와핑은 프로세스 혼합 상태를 개선하기 위하여 필요하기도 하며, 메모리 요구에 대한 변화가 가용 메모리에 비해 너무 많은 요구를 수용하여, 메모리를 자유화 시키기 위하여 필요하기도 한다.