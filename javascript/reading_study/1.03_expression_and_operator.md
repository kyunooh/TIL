# 표현식과 연산자
표현식은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다. 복합 표현식을 만드는 가장 쉬운 방법은 연산자를 사용하는 것이다.
## 기본 표현식
가장 간단한 형태의 표현식은 '기본 표현식'으로, 다른 표현식을 포함하지 않은 독립적 표현식이다. 기본 표현식은 상수나 리터럴 값, 특정 키워드들 그리고 변수 참조를 말한다.
프로그램 안에 존재하는 각 식별자들을 일단 변수라고 가정하고 값을 살펴본다. 만약 해당 식별자를 이름으로 하는 변수가 없다면, 해당 표현식은 undefined 값으로 평가된다. 하지만 ECMAScript 5의 엄격모드에서는 존재하지 않는 변수를 평가하려고 하면 ReferenceError 예외가 발생한다.
## 객체와 배열의 초기화 표현식
객체와 배열 초기화 표현식은 말 그대로 새로 생성된 객체나 배열을 값으로 하는 표현식이다. 이들 초기화 표현식은 종종 '객체 리터럴'과 '배열 리터럴'이라고 한다. 하지만 일반 리터럴과는 달리 이들은 기본 표현식이 아니다. 리터럴은 프로퍼티와 원소의 값을 지정하는 수많은 하위 표현식을 포함할 수 있기 때문이다.
배열 초기화 표현식은 대괄호 안에 담긴 쉼표로 구분된 표현식 리스트다. 배열 초기화 표현식의 값은 새로 생성된 배열이다.
배열 초기화 표현식에 사용되는 원소 표현식으로는 또 다른 배열 초기화 표현식을 사용할 수도 있다. 다시말해, 원소 표현식 자체가 배열이라면 중첩 배열을 만들 수도 있다는 말이다.
배열 초기화 표현식에 사용되는 원소 표현식은 매번 배열이 초기화될 때마다 평가된다. 이는 배열 초기화 표현식이 평가될 때마다 원소의 값이 달라질 수 있음을 뜻한다.
배열 리터럴에서 쉼표 사이의 값을 생략함으로써 원소의 값을 정의하지 않을 수 있다.
배열 초기화 표현식의 마지막 원소 표현식 다음에 쉠표가 올 수는 있지만, 그렇다고 해서 값이 정의되지 않은 원소가 만들어지지는 않는다.
객체 조기화 표현식은 배열 초기화 표현식과 유사하다. 하지만 대괄호가 아닌 중괄호가 사용되고, 각 하위 표현식 앞에는 프로퍼티 이름과 콜론이 붙는다.
객체 초기화에 사용한 표현식은 객체가 초기화 될 때마다 매번 평가되기 때문에 일정한 값을 갖지 않는다. 객체 리터럴에서의 프로퍼티 이름으로는 식별자 대신 문자열을 사용할 수도 있다.

## 함수 정의 표현식
함수 정의 표현식은 함수를 정의하고, 함수 정의 표현식의 값은 새로 정의된 함수다.  다시 말해 '함수 리터럴'이다. function 키워드와 중괄호로 둘러싸인 쉼표로 구분된 식별자(매개변수 이름) 목록, 중괄호로 둘러싸인 자바스크립트 코드(함수 몸체)로 이루어진다.

##프로퍼티 접근 표현식
프로퍼티 접근 표현식은 객체의 프로퍼티나 배열의 원소 값으로 평가된다. 자바스크립트에서는 두 가지 문법으로 프로퍼티에 접근할 수 있다. 
첫번째 프로퍼티 접근 방법은 표현식에 식별자를 점(.)으로 연결한 표현식이다. 여기서 표현식은 객체를 말하고, 식별자는 앞에서 지정한 객체에서 찾을 프로퍼티의 이름을 의미한다. 프로퍼티 접근의 두 번째 방법은 객체나 배열이 되는 첫 번째 표현식 다음에 열린 대괄호와 두 번째 표현식 그리고 닫힌 대괄호를 사용하는 것이다. 두 번째 표현식은 객체의 특정 프로퍼티 이름이나 배열내 원소의 값이 될 수 있다.
두 프로퍼티 접근 표현식 모두 점(.)이나 대괄호([) 왼쪽 표현식이 먼저 평가된다. 만약 평가된 값이 null이나 undefined이면 이들 값은 프로퍼티를 갖지 않기 때문에 표현식은 TypeError 예외를 발생시킨다. 값이 객체가 아니면 객체로 변환된다. 객체 표현식 다음에 즘(.)과 식별자가 올 경우에는 식별자를 이름으로 갖는 프로퍼티의 값을 찾게 되고, 이 값이 전체 표현식의 값이 된다. 객체 표현식 대음에 두 번째 표현식이 담긴 대괄호가 올 경웨ㅇ는 두 번째 표현식이 평가되고, 이 값이 문자열로 변환된다. 전체 표현식의 값을 앞에서 변환된 문자열을 이름으로 갖는 프로퍼티의 값이 된다. 객체에 해당 프로퍼티가 존재하지 않으면, 프로퍼티 접근 표현식의 값은 undefined가 된다.
. 식별자 문법이 두 방법 중 좀 더 간단하다. 하지만 접근하려는 프로퍼티 이름이 '합법적' 식별자일 때만 사용할 수 있고, 프로그램을 작성할 때 그 식별자를 미리 알고 있어야 한다. 만약 프로퍼티 이름이 예약어이거나, 구두점 문자나 공백을 포함하고 있거나, 숫자일 때는 반드시 대괄호를 사용해야 한다. 대괄호는 프로퍼티 이름이 고정되어 있지 않고, 그 이름 자체가 어떤 연산의 결과인 경우에도 사용할 수 있다.

## 호출 표현식
호출 표현식은 자바스크립트에서 함수나 메서드를 호출하는 문법이고, 호출될 함수를 가리키는 함수 표현식으로 시작한다. 그 뒤에는 여는 괄호로 시작해 쉼표(.)로 구분된 여러 개의 호출 인자 목록이 올 수 있고, 닫는 괄호로 끝난다.
호출 표현식이 평가될 때 함수 표현식이 가장 먼저 평가되고, 그 후에 호출 인자 표현식이 순서대로 인자 값으로 평가된다. 함수 표현식의 값이 호출할 수 있는 객체가 아닐 경우는 TypeError 예외가 발생하게 된다. 인자 값이 평가된 다음에는 함수 선언 시 지정했던 인자 이름에 인자 값이 차례로 할당되고, 마지막으로 함수의 본문이 실행된다. 값을 반환하기 위해 return문을 사용하면, 그 값이 결국 호출 표현식의 값이 된다. 함수가 값을 반환하지 않는다면, 함수 표현식의 값은 undefine가 된다. 
메서드가 호출되면 함수의 몸체가 실행되는 동안 프로퍼티 접근 표현식이 가르키는 객체나 배열이 모두 this의 값이 된다.
메서드 호출이 아닌 호출 표현식은 보통 전역 객체를 this 키워드의 값으로 사용한다. 하지만 strict모드에서 사용할 경우 전역 객체 대신 undefined 가 this의 값이 된다.
> 이 역시 함수 바깥에서는 this 를 쓰지 말자

## 객체 생성 표현식
객체 생성 표현식(object creation expression)은 새 객체를 생성하고, 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다.
객체의 생성자 함수를 전달인 없이 호출할 때, 괄호를 생략할 수 있다.
객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈 객체를 생성하는데, 이때 생성된 객체는 객체 초기자 {}에 의해 생성되는 객체와 동일하다. 주어진 인자들과 함께 생성자를 호출하는데, 이 때 방금 생성된 새 객체를 this 키워드의 값으로 설정하여 전달한다.

## 연산자 개요
연산자는 수식 표현식, 비교 표현식, 논리 표현식, 할당 표현식 등 자바스크립트에서 다양하게 쓰인다.
대부분의 연산자가 +는 = 같은 부호로 표현되지만, 일부는 delete와 instanceof와 같이 키워드로 표현한다. 키워드 연산자들도 문장 부호 연산자들과 마찬가지로 정규 연산자인데, 문장 부호 연산자와 비교해 덜 간결한 형태로 표현된 것뿐이다. 

### 피연산자 개수
연산자에 필요한 피연산자의 개수에 따라 연산자들을 분류할 수 있다.

### 피연산자와 반환 타입
일부 연산자는 값의 타입과 무관하게 동작하지만 대부분의 경우에는 피연산자 타입이 정해져 있다. 연산자들은 대체로 특정 타입의 값을 반환한다.
자바스크립트는 필요할 때마다 피연산자 타입을 변환한다. 곱셈 연산자 *는 두 개의 숫자 타입을 피연산자로 갖지만, 표현식 '3' * '5'는 자바스크립트가 두 개의 피연산자를 숫자로 바꾸기 때문에 특별히 문제가 되지 않는다. 이 표현식의 값은 문자열 "15"가 아니라 15다. 불리언 값을 피연산자로 갖는 연산자는 어떤 타입의 피연산자와도 문제없이 동작한다.

### 할당 연산자를 비롯한 몇 가지 연산자의 피연산자 타입은 '좌변 값'이다. 좌변 값이란 '할당 표현식의 좌변에 나타날 수 있는 표현식'에서 유래한 용어다. 자바스크립트에서는 변수, 객체 프로퍼티, 배열 원소가 좌변값이다. ECMAScript 명세에 의하면 내장 함수도 좌변 값을 반환할 수 있다고 한다. 하지만 실제로 이와 같은 형태로 정의된 내장 함수는 하나도 없다.

### 연산자 부수 효과
일부 표현식은 부수효과를 갖는다. 할당 연산자가 대표적인 경우인데, 변수나 객체의 프로퍼티에 값을 할당하면 그 변수나 프로퍼티를 사용하는 모든 표현식의 값이 바뀌는 것이다. delete연산자도 부수 효과가 있는데, 프로퍼티를 삭제하는 것은 해당 프로퍼티에 undefined 값을 할당하는 것과 유사하다.
다른 자바스크립트 연산자는 부수 효과가 없다. 하지만 함수 또는 생성자 몸체에 부수효과가 있는 연산자를 사용한다면 함수 호출 또는 객체 생성 표현식에서도 부수 효과가 나타날 수 있다. 

### 연산자 우선순위
연산자 우선순위는 연산이 수행되는 순서를 제어하는 기준이 된다.
프로퍼티 접근이나 호출 표현식은 나열된 연산자들보다 항상 우선순위가 높다.

### 연산자 결합 방향
연산자 결합 방향이 지정하는 것은 동일 우선순위 연산들 간의 수행 순서를 의미한다.

### 평가 순서
연산자 우선순위와 결합 방향은 복잡한 표현식에서 어떤 연산이 우선적으로 수행되는지를 결정한다.
표현식 x가 z에서 사용하고 있는 임의의 변수 값을 증가시킨다고 할 때, 여기서 중요한 점은 x가 반드시 z보다 먼저 평가되어야 한다.

## 산술 표현식
기본 산술 연산자는 *, /, %, +, -이다. 수로 변환 불가능한 피연산자는 NaN값으로 변환되면, 피연산자 중 하나라도 NaN일 경우에는 연산 결과도 NaN이다.
/연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈다.
자바스크립트에서 모든 숫자는 부동소수점 숫자로 취급된다. 따라서 모든 나눗셈 연산의 결과 또한 부동소수점 숫자 값이 된다. 예를 들어 5/2는 2가 아니라 2.5로 평가된다. 값을 0으로 나누면 양의 무한대 또는 음의 무한대 값이 되고 0/0의 값은 NaN로 평가된다.
일반적으로 나머지 연산자는 정수 타입의 피연산자에 대해 사용되지만, 부동 소수점 값에 대해서도 적용할 수 있다. 예를 들어 6.5 % 2.1의 결과는 0.2이다.

### 덧셈 연산자 +
`+` 연산자가 이항 연산자로 사용될 때는 피연산자 숫자 값을 더하거나 피연산자 문자열을 이어 붙인다.
두 피연산자 값이 모두 숫자거나 문자열인 겨우에는 + 연산자가 하는 일이 명학하다. 하지만 이 오의 경우에는 타입변환이 이루어져야 하고, 연산은 타입 변환이 이루어진 후에 수행된다. + 연산자는 타입 변환 시에 문자열을 이어 붙이기를 먼저 수행한다. + 연산자는 타입 변환 시에 이어붙이기를 먼저 수행한다. 피연산자 중 하나가 문자열이거나 문자열로 바꿀 수 있는 객체라면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어 붙인다. 덧셈은 두 피연산자 값이 모두 문자열이 아니거나 문자열로 변환될 수 없을 때만 수행된다. + 연산자의 동작 순서
- 만일 하나의 피연산자 값이 객체라면 객체를 원시 타입으로 바꾼다. Date 객체는 toString() 메서드에 의해 문자열로 바뀌고, 다른 객체들은 valueOf() 메서드가 원시 타입의 값을 반환하는 경우 그 반환값으로 변경된다. 그러나 대부분의 객체는 이처럼 유용한 valueOf() 메서드를 가지고 있지 않으므로, 그 대신 toString() 메서드를 통해 변환된다.
- 피연산자가 객체에서 원시 타입으로 변환된 후, 만일 어떤 피연산자라도 문자열이면, 다른 피연산자를 문자열로 변환한 후, 만일 어떤 피연산자라도 문자열이면, 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어 붙인다.
- 이 외의 경우에는 두 피연산자가 숫자로 변환되고 덧셈 연산이 수행된다.

### 단항 산술 연산자
단항 연산자는 하나의 피연산자 값을 수정해서 새 값으로 만든다. 단항 연산자가 가장 우선순위가 높고, 결합 방향은 모두 오른쪽에서 왼쪽에다. 산술 단항 연산자(+, -, ++, --)는 하나의 피연산자를 가능한 한 숫자 타입으로 변환하려 시도한다. 느낌표(!) 문자와 +, =는 단항과 이항 연산자 양쪽으로 사용할 수 있다.

#### 단항 덧셈(+)
단항 덧셈 연산자는 피연산자를 숫자(또는 NaN)로 바꾼 후 값을 반환한다. 만일 피연산자가 숫자인 경우에는 아무 일도 하지 않는다.

#### 단항 뺄셈(-)
뺄셈 연산자가 단항 연산자로 사용될 때는, 피연산자를 가능하면 숫자로 변환하려고 시도하고, 성공할 경우게, 결과 값의 부호를 바꾼다.

#### 증가(++)
`++` 연산자는 단항 피연산자에 대해 증가 연산을 한다. 이때 피연산자는 반드시 좌변 값(변수, 배열 원소 또는 객체 프로퍼티중 하나) 이어야 한다.
이 연산자의 결과 값은 피연산자의 어느 쪽에 연산자가 위치해 있는지에 따라 다르다. 피연산자의 앞에서 사용될 경우에는 전치 증가연산자라고 하며,  먼저 피연산자를 증가시킨 다음 증가된값을 결과로 내놓는다. 피연산자의 뒤에서 사용될 경우 후치증가연산 자라고 하며, 마찬가지로피 연산자를 증가시키지만 결과로는원래의 증가되지 않은 값을 내놓는다.

#### 감소(--)
-- 연산자는 단항 피연산자의 값을 숫자로 바꾼 후에 1을 뺀다. 그 다음에 감소한 값을 피연산자에 다시 할당한다.

### 비트 단위 연산자
비트 단위 연산자들은 2진수를 저수준에서 조작하는 데 사용한다. (자세한 내용은 책을 참고)

## 관계형 표현식
두 피연산자 값의 관계를 검사하여, 관계가 성립하면 true를 그렇지 않으면 false를 반환한다.

### 동치와 부등치 연산자
=== 연산자는 일치 (엄격한 동치) 연산자로 알려져 있는데, 두 피연산자가 '일치 하는지' 확인한다. == 연산자는 동치 연산자로 동치 연산자로 알려져 있으며, 두 피연산자가 '동등'한지 확인할 때 필요한 경우 타입 변환을 허용한다.
부등치 연산자 !=는 두 값이 서도 동치일 경우 false를 반환하며 그렇지 않을 경우 true를 반환한다. 불일치 연산자 !== 는 두 값이 서로 일치할 경우 false를 반환하며, 그렇지 않을 경우 true를 반환한다.

일치 연산자(===)는 다음의 규칙을 따른다.
- 두 값의 타입이 서로 다르면 두 값은 일치하지 않는다.
- 두 값이 모두 null이거나 모두 undefined면, 두 값은 일치한다.
- 두 값이 모두 불리언 값 true이거나 모두 false일 경우에, 두 값은 일치한다.
- 적어도 하나의 값이 NAN이면 두 값은 일치하지 않는다. NaN 값은 자기 자신을 포함해 다른 어떤한 값과도 일치하지 않는다. 임의의 값 x가 NaN인지 검사하기 위해서는 x !== x와 같이 사용하면 된다. NaN은 이 표현식을 참으로 만드는 유일한 값이다.
- 두 값이 모두 숫자고 같은 값을 갖는 다면, 두 값은 일치한다. 만약 하나의 값이 0이고 다른 하나의 값이 -0일지라도 두 값은 일치한다.
- 두 값이 모두 문자열이고, 같은 위치에 정확히 같은 16비트 값을 가지고 있다면 두 값은 일치한다.
- 두 값이 모두 같은 객체나 배열 또는 함수를 참조하고 있으면 두 값은 일치한다. 두 값이 서로 다른 객체를 참조할 경우에 설사 두 객체의 프로퍼티가 일치하더라도 두 값은 일치하지 않는다.

동치 연산자 (==)는 일치 연산자와 유사하지만 상대적으로 규칙이 엄격하지 않다.
- 두 값의 타입이 같은 경우, 두 값이 일치하는지 테스트한다. 만약 두 값이 일치할 경우 두 값은 동치다. 하지만 두 값이 일치하지 않으면 두 값은 동치가 아니다.
- 두 값의 타입이 다른 경우라 할지라도 동치일 여지가 있다. 동치임을 확인하는 과정에서 다음에 나요뎔ᅬᆫ 규칙들과 타입 변환이 사용된다.
- - 두 값 중 하나가 null이고 다른 하나가 undefined라면 두 값은 동등하다.
- - 한 값이 숫자이고 다른 하나가 문자열이면, 문자열을 숫자로 변환한 후 이를 사용해 다시 비교한다.
- - 두 값 중 하나가 true이면 이를 1로 변환한 후 다시 비교한다. 두 값 중 하나가 false이면, 이를 0으로 변환한 후 다시 비교한다.
- - 한 값이 객체고, 다른 하나는 숫자 또는 문자열이면, 객체를 원시 타입의 값으로 변환한 후 다시 비교한다. 객체를 원시 값으로 변환하는 데에는 해당 객체의 toString() 메서드나 valueOf() 메서드가 사용된다. 코어 자바스크립트의 내장 클래스에서는 toString() 메서드를 사용하기 전에 valueOf()메서드를 사용한 변환을 먼저 시도한다. 단, Date 클래스는 예외적으로 toString() 변환을 바로 수행한다. 

### 비교 연산자
- 피연산자 중 어느 하나가 객체로 평가되면 객체가 원시 값으로 변환된다. 이 과정에서 valueOf() 메서드의 반환값이 원시 타입이면 그 값을 이용하고, 그렇지 않은 경우 toString() 메서드의 반환값을 이용한다.
- 객체가 원시 타입으로 변환된 후에 피연산자가 모두 문자열이라면 '알파벳 순서'대로 두 문자열을 비교하게 된다.
- 둘 중의 하나의 피연산자가 NaN이거나 NaN으로 변환된다면 비교 연산자는 언제나 false를 반환한다.

### in 연산자
in 연산자는 좌변의 피연산자로 문자열을 받는다. 우변의 피연산자로는 객체나 배열을 받는다. 좌변 값이 우변 객체의 프로퍼티 이름에 해당할 경우 연산 결과는  true다.

### instanceof 연산자
instanceof 연산자는 좌변의 피연산자로 객체를, 우변의 피연산자로 객체 클래스의 이름을 식별자로 받는다. 좌변에 오는 객체가 우변 클래스의 인스턴스일 경우 연산 결과는 true로 평가된다. 객체의 클래스는 객체를 초기화하는 생성자 함수로부터 정의된다. 그러므로 instatnceof의 우변 피연산자는 함수가 되어야 한다.

모든 객체는 Object의 인스턴스라는 점을 기억하자. instanceof로 객체가 클래스의 인스턴스인지 판단할 때는 해당 객체의 '상위 클래스'들도 고려하게 된다. 마인ㄹ instanceof의 좌변 피연산자가 객체가 아니면, instanceof의 결과는 false다. 또한 우변 피연산자가 함수가 아니라면 TypeError 예외가 발생한다.
instanceof 연산자가 어떻게 동작하는지 이해하기 위해서는 '프로토타입 체인'을 이해해야 한다. 

## 논리 표현식
논리 연산자 &&, ||, 읒ㄴ 불리언 대수를 수행한다.

### 논리 AND
첫 번째 피연산자와 두 번째 피연산자가 '모두' true일 경우에만 연산 결과로 true를 반환한다. 적어도 하나 이상의 피연산자가 false라면 연산 결과로 false 반환한다.

자바스크립트 값은 true로 평가될 수 있거나 false로 평가될 수 있음을 상기하자. **false로 평가되는 값은 false, null, undefined, 0, -0, NaN, '' 이다. && 연산자를 이해하는 두 번째 방법은 true나  false로 평가되는 값들을 위한 불리언 AND 연산자로써 이해하는 것이다. 피연산자 모두 true로 평가되는 값이면 && 연산자는 true로 평가되는 값을 반환한다.
