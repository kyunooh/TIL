# 타입, 값, 변수
프로그래밍 언어로 다룰 수 있는 값의 유형을 **데이터 타입**이라고 한다. 프로그램은 값이 유지될 필요가 있을 때, **변수에 값을 할당**한다. 변수명은 그 값의 이름이므루, 그 이름을 통하면 **변수에 값을 참조**할 수 있다.
자바스크립트의 타입은 크게 **원시타입**과 **객체 타입**으로 나뉘고, 원시타입으로는 **숫자, 텍스트의 나열, 불리언 진리 값**이 있다.

자바스크립트에서 **null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입에 속한다.**

**숫자와 문자열, 불리언, null, undefined 외의 값은 객체다. 객체는 이름과 값을 갖는 프로퍼티의 집합**이다.
자바스크립트 객체는 **순서가 없는 값들의 집합**이며, **각 값에는 이름이 지정**되어 있다. **배열**이라고 알려진 특별한 종류의 객체도 있다. **배열은 순서가 있는 값들의 집합이며 각 값에는 번호가 부여된다.**

자바스크립트는 **함수라고 부르는 특별한 객체**도 갖고 있다. 함수는 **실행코드를 가지고 있는 객체**로서, 함수를 **호출하면 코드가 수행되고 계산된 값이 반환**된다. 배열과 마찬가지로 함수는 일반 객체와 다르게 동작한다. 그리고 자바스크립트는 함수를 실행하기 위한 특별한 문법을 가지고 있다. 함수에 대해 알아야 할 가장 중요한 점은 **함수는 값이고, 자바스크립트 프로그램은 함수를 보통 객체처럼 다룰 수 있다는 점이다.**

함수 중에는 **새로 생성된 객체를(new 연산자를 이용하여) 초기화히기 위해 사용되는 함수가 있는데, 이를 생성자(constructor) 함수**라고 한다. **생성자는 객체들의 클래스를 정의한다.** 여기서 객체는 생성자로 초기화되는 대상을 말한다. 클래스는 객체타입의 하위 타입으로 생각 할 수 있다. 코어 자바스크립트에서는 Array와 Function 클래스뿐만 아니라 세 개의 다른 유용한 클래스들을 정의하고 있다. **Date 클래스는 날짜를 표현하는 객체**를 정의하고, **RegExp 클래스는 정규 표현식을 표현하는 객체**를 정의한다. 그리고 **Error 클래스는 자바스크립트 프로그램에서 발생할 수 있는 문법과 런타임 에러를 표현하는 객체**를 정의한다.

자바스크립트 인터프리터는 **메모리 관리를 위해 자동으로 가비지 컬렉션**을 수행한다. 프로그램이 필요할 때 객체를 생성할 수 있고, 프로그래머는 이 객체를 어떻게 해제할지 걱정할 필요가 없다. **객체에 더 이상 접근할 수 없을 때 인터프리터는 그 객체가 다시 사용되지 않을거라 판단하고 자동으로 메모리에서 해제**한다.

자바스크립트는 **객체 지향 언어**다. 넓은 의미에서 이는, 다양한 **타입의 값을 다루는 전역 함수를 정의해두기보다, 어떤 값과 작동하는 메서드를 그 값의 타입에 정의**해둔다.

자바스크립트 **객체만이 메서드를 소유**한다. 하지만 **숫자, 문자열, 불리언 값은 메서드를 가진 것처럼 동작**한다. **null과 undefined는 자바스크립트에서 유일하게 메서드를 가질 수 없는 값**이다.

자바스크립트의 타입은 원시타입과 객체 타입으로 나뉠 수 있다. 메서드를 가진 타입과 그렇지 않은 타입 / **수정 가능한 타입과 불가능한 타입으로도 나뉠 수 있다.** **객체와 배열은 수정가능한 타입이다.** 객체프로퍼티와 배열 원소의 값을 변경할 수 있다. 숫자와 불리언, null, undefined는 수정할 수 없는 타입이다. 자바스크립트에서 **문자열은 수정할 수 없는 타입이다.**

자바스크립트의 값은 **타입 변환이 자유**롭다.

자바스크립트 **변수들은 타입이 정해져 있지 않다.** 변수에 어떤 타입의 값도 할당할 수 있고, 나중에 같은 변수에 다른 타입의 값을 할당할 수 있다. 변수는 var 키워드로 선언한다. **함수밖에서 선언된 변수들은 전역변수**고 자바스크립트 프로그램 어디서든 사용할 수 있다. **함수 안에 선언된 변수들은 유효범위가 함수영역이며, 오직 함수안에서만 사용가능**하다.

##숫자
다른 프로그래밍 언어들과는 다르게 자바스크립트는 **정수 값과 실수 값을 구분하지 않는다. 모든 숫자를 실수로 표현한다.**
**큰 정수 값을 사용한다면 낮은 자리에 대한 정밀도를 잃을 수도 있다.** 자바스크립트는 **배열 인덱싱이나 비트연산과 같은 특정한 연산은 32비트 정수로 수행한다.**

> 이것도 데인 적이 있다. 항상 주의하자!

숫자 그대로 등장하는 것은 숫자 리터럴이라고 한다. 숫자 리터럴은 첫 번째 숫자 왼편에 뺄셈기호(-)를 사용하는 방법으로 음수를 표현할 수 있다. 하지만 기술적으로 **(-)는 단항 부정 연산자이지, 숫자리터럴의 일부는 아니다.**

### 정수 리터럴
10진수 정수는 숫자를 일렬로 나열한것 다음과 같은 것들

- 0
- 3
- 100000000

16진수 리터럴은 '0x'나 '0X' 뒤에 16진수 숫자들이 뒤따르는 형태다.

ECMAScript 표준에서는 8진수 표현을 지원하지 않는다. 때문에 0으로 시작하는 정수 리터럴은 절대로 사용하지 말아야한다. Strict mode에서는 8진수 리터럴을 명시적으로 금지하고 있다.
> 그냥 8진수는 맘편히 쓰지 말자! + 표준은 약속이니까, 엥간해선 역시 표준을 따르자!

### 부동소수점 리터럴
부동소수점 리터럴은 실수를 표현하는 전통적인 문법을 따른다. 실수는 정수 부분과 소수점, 소수점 이하 부분으로 표현한다. 예제는 아래와 같다.

- 3.14
- 2345.789
- .3333333333333
- 6.01e23
- 1.4738223E-32

### 산술 연산
산술 연산자를 사용하여 숫자를 다룰 수 있다.

- (+)덧셈
- (-)뺄셈
- (*)곱셈
- (/)나눗셈
- (%)나머지

위의 연산자 뿐 아니라, 더 복잡한 수치 연산을 Math객체를 통해 지원한다.(책과 레퍼런스를 참고하자.)

자바스크립트의 산술 연산은 오버플로와 언더플로, 0으로 나누는 에러를 발생시키지 않는다.

- 산술 연산의 결과가 표현 할 수 있는 가장 큰 수보다 더 크다면, Infinity라고 표현하는 무한대의 값을 출력한다.
  -  가장 작은 음수 값보다 더 작은 값은 음의 무한대 -Infinity
- 언더플로는 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발생한다. 이경우 자바스크립트는 0을 돌려준다.
  - 언더플로가 음수에서 발생했다면 특수 값인 '음의 0'을 반환한다.
- 자바스크립트에서 0으로 나누는 연산은 에러가 아니다. 이런 경우에는 무한대 또는 음의 무한대가 반환된다.
- 0을 0으로 나누는 것은 NaN(Not a Number, 숫자가 아닙니당!)
  - NaN은 무한대를 무한대로 나누는 경우와 음수 값에 루트를 씌우는 경우, 숫자가 아닌 피연산자로 산술 연산을 시도하는 경우에도 발생한다.

> 설명만 봐도 괴상한 경우에만 NaN이 발생하는 듯 하다. 숫자가 아닌 피연산자로 산술 연산 시도는
> `[] - {}, "" - {}`
> 이런짓을 하면 발생한다.

자바스크립트는 Infinity, NaN이 전역변수에 미리 정의한다. ECMAScript 3에선 읽고 쓰기가 가능하지만, ECMAScript 5에선 읽기 전용이다. ECMAScript는 Number 객체에도 적용되어 있는데, 이들은 읽기 전용이다.

> 스스로 짠 코드에 한해서, 그냥 맘편하게 읽기 전용이라고 생각하고 쓰면 될 듯하다.

NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교할 수 없다. 변수 x가 NaN인지 판단하기 위해 x == NaN 문을 작성할 수 없다.

> 뭐죠 이게...

대신에 x != x 라고 작성해야 한다. x가 NaN이라면 이 표현식은 참일 것이다.

> 혼란하다 혼란해... (이거 웬지 SQL에서도 비슷한 걸 본것 같은데...)

isNaN() 함수는 이러한 경우에 유용하게 사용할 수 있다.

> 그렇지 이런 함수가 있어야지... (코어 전역변수 같은데 나중에 자세히 알아봐야지..)

이 함수는 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다.

> 아니 그럼 NaN만 검사하는 게 아니잖아.. 정말 is not a number 잖아... 

~~`function isRealNaN(someVar) {`
> `if(isNaN(someVar)) {`
>>`if(someVar != someVar) {`
>>>`return true;`

>>`}`

>`}`

>`return false;`

`}`
> 대충 이런식으로 구현하면 되긴 되는 듯 보인다.
>> 맨정신에 보니 내가 왜 위같은 코드를 짰는 지 모르겠다. 정말 쓸모없는 코드를 쓴 것 같다. + 정말 함수로 빼고 싶다면 `function isNaNType(x) { if(x!=x) return true; return false;}`이정도면 충분할 듯...

이와 유사한 함수 isFinite()는 인자가 NaN, Infinty 또는 -Infinty 이외의 숫자라면 참을 반환한다.
> 당연하게 숫자가 아니면 false를 뿜!

자바스크립트에서 실수 연산을 할 때는 근사 값으로 표현한다. IEEE-754 부동소수점 표현방식은 1/2, 1/8, 1/1024같은 분수를 정확하게 표현할 수 있는 이진 표현법이다. 하지만 가장 많이 사용하는 10진수 분수는 표현할 수 없기 때문에, 0.1과 같은 간단한 값도 정확하게 표현할 수 없다.
자바스크립트의 다음 버전은 이런 반올림 문제를 피하는 십진수 타입을 지원할 것이다. 하지만 그때 까지 민감한 계산에는 정수값을 이용해야 한다.
## 텍스트
문자열은 16비트 값들이 연속적으로 나열된 변경이 불가능한 값, 각 문자는 유니코드 문자로 표현된다. 문자열의 길이 값은 문자열에 들어 있는 16비트 값의 개수다. (유니코드에서 UTF-16을 사용한다.)
### 문자열 리터럴
문자열을 작은 따옴표 혹은 큰 따옴표로 둘러 싸면된다
ECMAScript 3(이하 ECMA3)에선 문자열 리터럴은 한줄로 작성해야 한다. 하지만 ECMAScript 5(이하 ECMA5)에서는 줄 끝에 역슬래시를 놓으면 한줄을 여러줄로 작성할 수 있다.
### 문자열 리터럴 내의 이스케이프 문자열
> 이건 그냥 책을보자

### 문자열 다루기
숫자에 + 연산자를 적용하면 숫자들이 더해진다. 하지만 문자열에 적용하면 두 번째 문자열을 첫 번째 문자열에 이어 붙인다.
문자열 s의 길이를 length 프로퍼티를 사용한다.

### 패턴 매칭
자바스크립트는 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 정의한다. 자바스크립트는 정규 표현식을 위해 펄(Perl)의 구문을 따른다. 문자열과 RegExp 객체는 모두 패턴 매칭과 '검색 후 바꾸기'기능을 수행하는 메서드를 가진다.
RegExp는 자바스크립트의 원시 타입이 아니다.
RegExp가 자바스크립트의 기본 데이터 타입은 아니지만, 자바스크립트는 정규식에 대한 리터럴 문법을 가지고 있고, 이는 자바스크립트 프로그램으로 바로 해석될 수 있다. 한 쌍의 슬래시 사이에 있는 문자열은 정규 표현식 리터럴을 구성한다. 한쌍의 슬래시 중 두 번째 슬래시 뒤에는 하나 혹은 그 이상의 문자가 뒤따라 올 수 있는데, 이것은 패턴의 의미를 수정할 수 있다.

## 불리언 값
**불리언 값은 참/거짓을 표현한다. 불리언 값이 될 수 있는 표현식은 항상 예약어인 true와 false 중 하나의 값으로 평가된다.**

## null과 undefined
**null은 보통 아무 값도 갖지 않음을 가리킬 때 사용되며, 특별한 값을 평가하는 키워드다. typeof 연산자를 null에 사용하면 문자열 "object"를 반환한다.** null은 "객체가 없음"을 뜻하는 특수한 객체 값으로 생각할 수 있다.
**값이 없음을 나타내는 또 다른 값, undefined가 있다. undefined는 null보다도 심한 부재 상태를 나타낸다.** undefined는 초기화되어 있지 않은 변수나, 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 얻는 값이다. 또한 undefined는 반환값이 없는 함수의 반환값이고, 실 인자가 전달되지 않은 형식인자의 값이다. undefined는 미리 선언된 전역 변수이며, 정의되지 않은 값으로 초기화 된다.
**null과 undefined는 둘 다 false로 판정되는 값이면 불리언 값 false로 변환된다.** null과 undefined는 프로퍼티와 메서드를 가지고 있지 않기 때문에, 실제로 프로퍼티 혹은 메서드에 접근하기 위해 연산자나 []를 사용하면 TypeError가 발생한다.

## 전역 객체
전역 객체는 매우 중요한 용도로 사용되는 일반적인 자바스크립트 객체다. **전역 객체의 프로퍼티는 자바스크립트 프로그램 전역에서 사용할 수 있게 정의된 심벌**이다.

## 래퍼(wrapper) 객체
자바스크립트 객체는 복합적인(composite) 값이다. 객체는 프로퍼티 또는 이름있는 값들의 집합이며, 표기법을 사용하여 프로퍼티의 값을 참조한다. **프로퍼티의 값이 함수일 때, 그 함수를 메서드라 부른다.**

## 변경 불가능한 원시 타입 값과 변경 가능 객체 참조
자바스크립트에서 원시 타입 값과 객체 사이에는 근본적인 차이점이 있다. 바로 **원시 타입의 값은 수정할 수 없다는 점이다.**
문자열은 문자들의 배열과 같기 때문에, 특정 배열의 원소를 변경할 수 있다고 생각할지 모른다. 하지만 자바스크립트에서는 실제로 문자열의 각 문자를 변경할 수 없다. **문자열을 수정하는 모든 문자열 메서드는 새로운 문자열을 반환한다.** (책을 보자)
객체는 원시 타입과는 다르다. **객체는 자신의 값을 변경할 수 있다(mutable).**
**객체는 값으로 비교되지 않는다.** 다시 말해, **두 객체가 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다. 그리고 두 배열은 같은 순서로 같은 원소를 갖고 있어도 같지 않다.**
**객체는 참조 타입으로 불리는데**, 이는 자바스크립트의 원시 타입과 구별하기 위해서다.
객체를 변수에 할당하는 것은 단순히 **참조를 할당하는 것**이다.
> 오랜만에 보는 참조다. 이번주 떡밥을 찾았다.

## 타입 변환
자바스크립트는 타입에 대해 매우 유연하다. 자바스크릴트는 그 값을 필요에 따라 변환할 것이다. 어떤 값은 true로 변환하고 다른 값들은 false로 변환한다. 예외적으로 null과 undefined는 변환할 수 없다.
### 변환과 동치
자바스크립트는 값의 타입을 유연하게 변환시킬 수 있다. 동치 연산도 ==도 유연하게 동작한다.

### 명시적 변환
자바스크립트는 많은 형 변환을 자동으로 수행하지만, 명시적 변환이 필요할 때가 있다. 코드를 깔끔하게 유지하기 위해, 변환을 명시적으로 하는 것을 더 선호 할 수도 있다.
명시적으로 타입 변환을 수행하는 가장 간단한 방법은 Boolean(), Number(), String(), Object() 함수를 사용하는 것이다.
null과 undefined를 제외한 모든 값은 toString() 메서드를 가지고 있으며, 이 메서드의 결과는 보통 String() 함수가 반환하는 값과 같다. null과 undefined를 객체로 변환하려고 하면 TypeError가 발생한다고 명시하고 있다. 그러나 Object()함수는 이런 경우에 예외를 발생시키지 않는다. 대신 새로 생성된 빈 객체를 반환한다.
`+` 연산자는 한 피연산자가 문자열이라면 다른 피연산자를 문자열로 변환한다.
Number 클래스에 정의된 toString() 메서드는 기수를 정하는 선택적 인자를 받는다. 이 인자들을 전달하지 않는다면 기수를 10으로 하여 변환을 수행한다. 2에서 36까지의 값을 전달하면 해당 숫자를 기수로 하여 변환한다.
> 궁금해서 36을 넘겨보니 RangeError가 난다....

toFixed() 메서드는 결과 문자열의 소수점 이하 자릿수 개수를 인자와 똑같이 맞춘 문자열을 반환한다. toFixed() 메서드는 지수 표기법을 사용하지 않는다. toExponential() 메서드는 지수 표기법을 사용하여 소수점 앞에 숫자 하나와 소수점 뒤에 인자로 지정한 만큼의 자릿수를 놓는 방식으로 숫자를 문자열로 변환한다. toPrecision() 메서드는 여러분이 정의한 유효 자릿수로 숫자를 문자열로 변환한다. toPrecision() 은 유효 자릿수가 숫자의 전체 정수 부분을 표시할 정도로 크지 않다면 지수 표기법을 사용한다.
parseInt()와 parseFloat() 함수는 리터럴의 일부가 숫자가 아니어도 된다는 점에서 Number()보다 좀더 유연하게 동작한다. 참고로 parseInt()와 parseFloat() 함수는 Number 클래스의 메서드가 아닌 전역 함수다. parseInt()는 정수만 변환할 수 있지만 parseFloat()는 정수와 부동소수점 모두 변환할 수 있다. 만약 문자열이 '0x'나 '0X'로 시작하면 parseInt()는 문자열을 16진수 숫자로 인식한다.
기수를 정의하는 선택적인 두 번째 인자를 받는다. 숫자는 2와 36사이에서 유효하다.
> 아 36인 이유는 (0 ~ z)까지 이기 때문이다.
> 덤으로 역자 주에 0으로 시작하는 문자열은 parseInt() 시에 8진수로 인식할 수 있으므로 0으로 시작하는 문자열에는 절대 parseInt()를 쓰지 말라고 한다. 10진수면 기수를 넘겨주자!

### 객체에서 원시 타입으로 변환
모든 객체는 true로 변환된다. new Boolean(false)는 원시타입이 아니라 객체이므로 true로 변환된다.
이번 절에서 설명한 문자열과 숫자로의 전환 규칙은 오직 네이티브 객체에만 적용가능하다.
모든 객체는 두 개의 타입변환 메서드를 상속한다. 첫 번째 메서드는 toString()인데, 이 메서드는 객체를 문자열로 표현하여 반환한다.
Function 클래스에 정의된 toString() 메서드는 자바스크립트 구현체가 정의하는 함수의 내부 표현형을 반환한다.
기본적으로 valueOf() 메서드는 원시 타입을 반환하지 않고 단순히 객체 그 자신을 반환한다. 래퍼 클래스는 래핑된 원시 타입의 값을 반환하는 valueOf() 메서드를 정의한다. 배열, 함수, 정규 표현식은 단순히 기본 메서드를 상속한다.
기본적으로 valueof() 메서드는 원시 타일을 반환하지 않고 산훈ㅣ 객체 그 자신을 반환한다. 래퍼 클래스는 래핑된 원시 타입의 값을 반환하는 valueOf() 메서드를 정의한다. 배열, 함수, 정규 표현식은 단순히 기본 메서드를 상속한다.
Date 클래스의 valueOf() 메서드는 객체 내부적으로 날짜를 표현하기 위해 쓰는 값(mili second)을 반환한다

#### 객체를 문자열로 변환하는 과정
- 객체가 toString() 메서드를 가지고 있다면, 자바스크립트는 이 메서드를 호출한다. toString()이 원시 타입값을 반환한다면, 자바스크립트는 이 값을 문자열로 변환하여(이미 문자열이 아니라면) 반환한다ㅣ
- 객체가 toString() 메서드를 가지고 있지 않거나 이 메서드가 원시 타입값을 반환하지 않는다면 자바스크립트는 valueOf() 메서드를 찾는다. valueOf()메서드가 존재한다면 자바스크립트는 이 메서드를 호출한다.
- 그렇지 않다면 자바스크립트는 toString() 또는  valueOf()로부터 원시 타입값을 얻을 수 없기 때문에 TypeError를 발생시킬 것이다.
> 객체가 toString() 또는 valueOf()를 가지고 있지 않은 경우는 plain object 일 때며, Object.create(null)을 이용해서 생성 가능하다.


#### 객체를  숫자로 전환할 때는 문자열과 같은 방식으로 전환하지만, valueOf() 메서드를 먼저 호출한다.
- 객체가 원시 타입의 값을 반환하는 valueOf() 메서드를 가지고 있다면, 자바스크립트는 반환된 값을 (필요하다면) 숫자로 변환하여 반환한다.
- 그렇지 않고, 객체가 원시 타입값을 반환하는 toString() 메서드를 가지고 있다면 자바스크립트는 이 값을 변환하여 반환한다.
- 이 외의 경우, 자바스크립트는 TypeEroor를 발생시킨다.

##### 빈 배열이 숫자 0으로 반환되는 이유
배열은 기본적으로 원시 타입 값 대신 객체를 반환하는 valueOf() 메서드를 상속하기 때문에, 배열에서 숫자로의 변환은 toString()메서드에 의존한다. 빈 배열은 빈 문자열로 변환된다. 그리고 다시 빈 문자열은 숫자 0으로 변환된다. 한개의 원소를 가진 배열은 해당 원소와 같은 문자열로 변환한다. 만약 배열이 한개의 숫자만 가지고 있다면 이 숫자는 문자열로 변환되고, 그다음에 숫자로 다시 변환된다.

`+` 연산자는 숫자 덧셈과 문자열 붙이기를 수행한다. + 연산자의 피연산자 중하나가 객체라면, 객체를 다른 산술 연산처럼 객체에서 숫자로 변환하는 대신 객체에서 원시 타입으로 변환한다. == 동치 연산자도 비슷하다. 객체를 원시 타입 값과 비교할 때는, 객체를 원시 타입으로 변환한다.
Date 클래스는 코어 자바스크립트에 포함되어 있는 타입 가운데, 문자열로의 변환 절차와 수로의 변환 절차를 전부 구현하고 있는 유일한 타입이다. 객체에서 원시 타입으로의 변환은 객체에서 숫자로의 변환이고, 이때 valueOf()를 먼저 사용한다. Date 객체에 한해서만 객체에서 문자열로 변환하며 이때 toString()을 먼저 사용한다. 
> 특별한 Date 이군

## 변수 선언
변수는 var 키워드를 이용하여 선언한다.
자바스크립트에서는 변수에 숫자를 할당했다가 나중에 문자열을 할당해도 문법적으로 문제가 없다.

### 반복된 선언과 생략된 선언
반복된 변수 선언에 초기값이 부여된 경우, 선언문은 마치 대입문처럼 동작한다.
선언하지 않은 변수를 읽으려 하면 자바스크립트는 에러를 발생시킨다. non-strict mode에서 선언하지 않은 변수에 값을 배정하면, 그 변수는 전역 객체의 속성으로 생성되어, 마치 미리 선언했던 전역 변처럼 동작하게 된다(하지만 완전히 같지는 않다.) **항상 변수는 var로 선언하도록 해야한다.**

## 변수의 유효범위
전역 변수는 자바스크립트 코드 전체에 걸쳐 정의되어 있다. 어떤 함수 안에서 선언된 변수는 오직 해당 함수 몸체 안에서만 정의된다. 이런 변수는 지역 변수라 불리며 유효범뒤도 지역적이다. 

### 함수 유효범위와 끌어올림(hoisting)
지역 변수는 함수 전체에 걸쳐서 정의된다. 즉, 같은 이름의 전역 변수는 함수 전체에서 이 지역 변수에 의해 감춰진다. 지역 변수가 함수 전체에 걸쳐 정의되었더라도 var문이 실행되고 나서야 실제로 초기화된다.

### 프로퍼티로서의 변수
생성된 변수는 전역 개체의 평범하고 수정 가능한(configurable) 프로퍼티이며 삭제할 수도 있다.
자바스크립트 전역 변수는 전역 객체의 프로퍼티다. 변수를 각 함수 호출과 연관된 객체의 프로퍼티로 생각해도 된다. 지역 변수가 저장된 객체를 참조할 방법은 제공하지 않는다.

### 유효범위 체인 
변수의 유효범위란 정의된 변수를 사용 가능한 소스 코드의 집합으로 생각할 수 있다. 전역 변수는 프로그램 전체에 걸쳐 유효하다.
지역 변수를 객체의 프로퍼티로 생각한다면, 변수 유효범위를 다른 관점으로 볼 수도 있다. 자바스크립트의 모든 코드 무더기는 그것과 연관된 유효범위 체인을 가지고 있다 유효범위 체인은 해당 코드 무더기의 범위 안에 있는 변수를 정의하는 객체의 체인 다시 말해 리스트다.
