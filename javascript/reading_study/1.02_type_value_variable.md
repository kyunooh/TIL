# 타입, 값, 변수
프로그래밍 언어로 다룰 수 있는 값의 유형을 **데이터 타입**이라고 한다. 프로그램은 값이 유지될 필요가 있을 때, **변수에 값을 할당**한다. 변수명은 그 값의 이름이므루, 그 이름을 통하면 **변수에 값을 참조**할 수 있다.
자바스크립트의 타입은 크게 **원시타입**과 **객체 타입**으로 나뉘고, 원시타입으로는 **숫자, 텍스트의 나열, 불리언 진리 값**이 있다.

자바스크립트에서 **null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입에 속한다.**

**숫자와 문자열, 불리언, null, undefined 외의 값은 객체다. 객체는 이름과 값을 갖는 프로퍼티의 집합**이다.
자바스크립트 객체는 **순서가 없는 값들의 집합**이며, **각 값에는 이름이 지정**되어 있다. **배열**이라고 알려진 특별한 종류의 객체도 있다. **배열은 순서가 있는 값들의 집합이며 각 값에는 번호가 부여된다.**

자바스크립트는 **함수라고 부르는 특별한 객체**도 갖고 있다. 함수는 **실행코드를 가지고 있는 객체**로서, 함수를 **호출하면 코드가 수행되고 계산된 값이 반환**된다. 배열과 마찬가지로 함수는 일반 객체와 다르게 동작한다. 그리고 자바스크립트는 함수를 실행하기 위한 특별한 문법을 가지고 있다. 함수에 대해 알아야 할 가장 중요한 점은 **함수는 값이고, 자바스크립트 프로그램은 함수를 보통 객체처럼 다룰 수 있다는 점이다.**

함수 중에는 **새로 생성된 객체를(new 연산자를 이용하여) 초기화히기 위해 사용되는 함수가 있는데, 이를 생성자(constructor) 함수**라고 한다. **생성자는 객체들의 클래스를 정의한다.** 여기서 객체는 생성자로 초기화되는 대상을 말한다. 클래스는 객체타입의 하위 타입으로 생각 할 수 있다. 코어 자바스크립트에서는 Array와 Function 클래스뿐만 아니라 세 개의 다른 유용한 클래스들을 정의하고 있다. **Date 클래스는 날짜를 표현하는 객체**를 정의하고, **RegExp 클래스는 정규 표현식을 표현하는 객체**를 정의한다. 그리고 **Error 클래스는 자바스크립트 프로그램에서 발생할 수 있는 문법과 런타임 에러를 표현하는 객체**를 정의한다.

자바스크립트 인터프리터는 **메모리 관리를 위해 자동으로 가비지 컬렉션**을 수행한다. 프로그램이 필요할 때 객체를 생성할 수 있고, 프로그래머는 이 객체를 어떻게 해제할지 걱정할 필요가 없다. **객체에 더 이상 접근할 수 없을 때 인터프리터는 그 객체가 다시 사용되지 않을거라 판단하고 자동으로 메모리에서 해제**한다.

자바스크립트는 **객체 지향 언어**다. 넓은 의미에서 이는, 다양한 **타입의 값을 다루는 전역 함수를 정의해두기보다, 어떤 값과 작동하는 메서드를 그 값의 타입에 정의**해둔다.

자바스크립트 **객체만이 메서드를 소유**한다. 하지만 **숫자, 문자열, 불리언 값은 메서드를 가진 것처럼 동작**한다. **null과 undefined는 자바스크립트에서 유일하게 메서드를 가질 수 없는 값**이다.

자바스크립트의 타입은 원시타입과 객체 타입으로 나뉠 수 있다. 메서드를 가진 타입과 그렇지 않은 타입 / **수정 가능한 타입과 불가능한 타입으로도 나뉠 수 있다.** **객체와 배열은 수정가능한 타입이다.** 객체프로퍼티와 배열 원소의 값을 변경할 수 있다. 숫자와 불리언, null, undefined는 수정할 수 없는 타입이다. 자바스크립트에서 **문자열은 수정할 수 없는 타입이다.**

자바스크립트의 값은 **타입 변환이 자유**롭다.

자바스크립트 **변수들은 타입이 정해져 있지 않다.** 변수에 어떤 타입의 값도 할당할 수 있고, 나중에 같은 변수에 다른 타입의 값을 할당할 수 있다. 변수는 var 키워드로 선언한다. **함수밖에서 선언된 변수들은 전역변수**고 자바스크립트 프로그램 어디서든 사용할 수 있다. **함수 안에 선언된 변수들은 유효범위가 함수영역이며, 오직 함수안에서만 사용가능**하다.

##숫자
다른 프로그래밍 언어들과는 다르게 자바스크립트는 **정수 값과 실수 값을 구분하지 않는다. 모든 숫자를 실수로 표현한다.**
**큰 정수 값을 사용한다면 낮은 자리에 대한 정밀도를 잃을 수도 있다.** 자바스크립트는 **배열 인덱싱이나 비트연산과 같은 특정한 연산은 32비트 정수로 수행한다.**

> 이것도 데인 적이 있다. 항상 주의하자!

숫자 그대로 등장하는 것은 숫자 리터럴이라고 한다. 숫자 리터럴은 첫 번째 숫자 왼편에 뺄셈기호(-)를 사용하는 방법으로 음수를 표현할 수 있다. 하지만 기술적으로 **(-)는 단항 부정 연산자이지, 숫자리터럴의 일부는 아니다.**

### 정수 리터럴
10진수 정수는 숫자를 일렬로 나열한것 다음과 같은 것들

- 0
- 3
- 100000000

16진수 리터럴은 '0x'나 '0X' 뒤에 16진수 숫자들이 뒤따르는 형태다.

ECMAScript 표준에서는 8진수 표현을 지원하지 않는다. 때문에 0으로 시작하는 정수 리터럴은 절대로 사용하지 말아야한다. Strict mode에서는 8진수 리터럴을 명시적으로 금지하고 있다.
> 그냥 8진수는 맘편히 쓰지 말자! + 표준은 약속이니까, 엥간해선 역시 표준을 따르자!

### 부동소수점 리터럴
부동소수점 리터럴은 실수를 표현하는 전통적인 문법을 따른다. 실수는 정수 부분과 소수점, 소수점 이하 부분으로 표현한다. 예제는 아래와 같다.

- 3.14
- 2345.789
- .3333333333333
- 6.01e23
- 1.4738223E-32

### 산술 연산
산술 연산자를 사용하여 숫자를 다룰 수 있다.

- (+)덧셈
- (-)뺄셈
- (*)곱셈
- (/)나눗셈
- (%)나머지

위의 연산자 뿐 아니라, 더 복잡한 수치 연산을 Math객체를 통해 지원한다.(책과 레퍼런스를 참고하자.)

자바스크립트의 산술 연산은 오버플로와 언더플로, 0으로 나누는 에러를 발생시키지 않는다.

- 산술 연산의 결과가 표현 할 수 있는 가장 큰 수보다 더 크다면, Infinity라고 표현하는 무한대의 값을 출력한다.
  -  가장 작은 음수 값보다 더 작은 값은 음의 무한대 -Infinity
- 언더플로는 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발생한다. 이경우 자바스크립트는 0을 돌려준다.
  - 언더플로가 음수에서 발생했다면 특수 값인 '음의 0'을 반환한다.
- 자바스크립트에서 0으로 나누는 연산은 에러가 아니다. 이런 경우에는 무한대 또는 음의 무한대가 반환된다.
- 0을 0으로 나누는 것은 NaN(Not a Number, 숫자가 아닙니당!)
  - NaN은 무한대를 무한대로 나누는 경우와 음수 값에 루트를 씌우는 경우, 숫자가 아닌 피연산자로 산술 연산을 시도하는 경우에도 발생한다.

> 설명만 봐도 괴상한 경우에만 NaN이 발생하는 듯 하다. 숫자가 아닌 피연산자로 산술 연산 시도는
> `[] - {}, "" - {}`
> 이런짓을 하면 발생한다.

자바스크립트는 Infinity, NaN이 전역변수에 미리 정의한다. ECMAScript 3에선 읽고 쓰기가 가능하지만, ECMAScript 5에선 읽기 전용이다. ECMAScript는 Number 객체에도 적용되어 있는데, 이들은 읽기 전용이다.

> 스스로 짠 코드에 한해서, 그냥 맘편하게 읽기 전용이라고 생각하고 쓰면 될 듯하다.

NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교할 수 없다. 변수 x가 NaN인지 판단하기 위해 x == NaN 문을 작성할 수 없다.

> 뭐죠 이게...

대신에 x != x 라고 작성해야 한다. x가 NaN이라면 이 표현식은 참일 것이다.

> 혼란하다 혼란해... (이거 웬지 SQL에서도 비슷한 걸 본것 같은데...)

isNaN() 함수는 이러한 경우에 유용하게 사용할 수 있다.

> 그렇지 이런 함수가 있어야지... (코어 전역변수 같은데 나중에 자세히 알아봐야지..)

이 함수는 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다.

> 아니 그럼 NaN만 검사하는 게 아니잖아.. 정말 is not a number 잖아... 

`function isRealNaN(someVar) {`
> `if(isNaN(someVar)) {`
>>`if(someVar != someVar) {`
>>>`return true;`

>>`}`

>`}`

>`return false;`

`}`
> 대충 이런식으로 구현하면 되긴 되는 듯 보인다.

이와 유사한 함수 isFinite()는 인자가 NaN, Infinty 또는 -Infinty 이외의 숫자라면 참을 반환한다.
