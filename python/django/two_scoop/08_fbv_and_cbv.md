# 함수 기반 뷰(FBV)와 클래스 기반 뷰(CBV)
## 함수 기반뷰와 클래스 기반 뷰를 각각 언제 이용할 것인가?
매번 뷰를 구현할 때마다 어떤 뷰가 적당할지 생각하자. 어떤 뷰를 이용해야 할 지 모를땐 책의 순서도를 참고하자.
> 뭔가 CBV 만세 느낌이다...

## URLConf로 부터 뷰 로직을 분리하기
장고로 오는 요청들은 흔히 urls.py라는 모듈 내에서 URLConf를 통해 뷰로 라우팅된다. 장고의 URL 디자인 철학에 따르면 뷰와 URL의 결합은 최대한의 유연성을 제공하기 위해 느슨하게 구성되어야 하며 이는 많은 경험이 요구되는 일이다.
장고는 아주 단순하고 명료하게  URL 라우트를 구성하는 방법을 제공한다는 사실을 명심하자. 다른 모든 주제와 마찬가지로 이 단순 명료함은 항상 다른 것보다 우선시되어야 한다. 여기 우리의 경험에서 나온 방법론이다.
1. 뷰 모듈은 뷰 로직을 포함해야 한다.
2. URL 모듈은 URL 로직을 포함해야 한다.

### URLConf에서 느슨한 결합 유지하기
코드의 양이 많으므로 책을 참고하자!

### 클래스 기반 뷰를 사용하지 않는다면?
__file__속성을 이용하여 디렉터리 워킹과 정규 표현식을 혼합하여 자동으로 URLConf를 생성하는 정교한 트릭을 이용한 확장을...
여튼 그냥 URLConf로 부터 로직을 분리해서 운영하자

## 추가적인 모델 테스팅 팁
URL 이름 공간은 앱 레벨 또는 인스턴스 레벨에서의 구분자를 제공한다. URL 이름공간은  필요 없어보이지만 이용하기 시작하면 왜 그동안 쓰지 않았을까 생각이 드는 것 중 하나다

### URL이를음  짧고, 명환하고, 반복되는 작업을 피해서 작성하는 방법
예제에서 tastings_detail이나 tastings_results처럼 모델이나 앱의 이름을 복사한 URL 이름들은 더 이상 볼 수 없다. 대신 detail이나 results 같은 좀더 명확한 이름이 보인다. 이는 장고에 처음 입문하는 개발자들이 앱을 좀 더 쉽게 이해하는 데 도움이 된다. 

### 서드 파티 라이브러리와 상호 운영성을 높이기 
URL 이름을 "(myapp)\_detail" 등의  방법으로 부를 때 생기는 또 다른 문제는 이  (myapp)부분이 서로 겹칠 때 벌어진다. 우리의 tastings 앱과 같은 경우에 문제가 되지는 않지만 제작자의 블로그나 주소록 애플리케이션의 경우 충분히 문제가 될 수 있다. 이런 굥우 URL 이름공간을 통해 이를 간단히 해결할 수 있다. 예제는 책을 참고하자


